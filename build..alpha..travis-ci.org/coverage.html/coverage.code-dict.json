{"/home/travis/build/npmtest/node-npmtest-elastical/test.js":"/* istanbul instrument in package npmtest_elastical */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-elastical/lib.npmtest_elastical.js":"/* istanbul instrument in package npmtest_elastical */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_elastical = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_elastical = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-elastical/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-elastical && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_elastical */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_elastical\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_elastical.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_elastical.rollup.js'] =\n            local.assetsDict['/assets.npmtest_elastical.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_elastical.__dirname + '/lib.npmtest_elastical.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-elastical/node_modules/elastical/index.js":"/**\n@module elastical\n**/\n\nmodule.exports = {\n    Client: require('./lib/client'),\n    Index : require('./lib/index')\n};\n","/home/travis/build/npmtest/node-npmtest-elastical/node_modules/elastical/lib/client.js":"/**\nElasticSearch client implementation.\n\n@module elastical\n@submodule client\n**/\n\nvar request = require('request').defaults({encoding: 'utf8'}),\n    util    = require('./util'),\n    Index = require('./index'),\n    encode = encodeURIComponent;\n\n/**\nCreates a new Elastical client associated with the specified _host_. The client\nuses ElasticSearch's REST API to interact with the host, so connections are\nestablished as needed and are not persistent.\n\n@example\n\n    // Create a client that connects to http://127.0.0.1:9200\n    var elastical = require('elastical'),\n        client    = new elastical.client();\n\n@class Client\n@param {String} [host=\"127.0.0.1\"] Hostname to connect to.\n@param {Object} [options] Client options.\n    @param {String} [options.auth] Username and password (delimited by a \":\") to\n        pass to ElasticSearch using basic HTTP auth. If not specified, no\n        authentication will be used. Be sure to set `options.protocol` to\n        'https' unless you're comfortable sending passwords in plaintext.\n    @param {Boolean} [options.curlDebug=false] If `true`, runnable curl commands\n        will be written to stderr for every request the client makes. This is\n        useful for debugging requests by hand.\n    @param {Number} [options.port=9200] Port to connect to.\n    @param {String} [options.protocol='http'] Protocol to use. May be \"http\" or\n        \"https\".\n    @param {String} [options.basePath=''] Optional base path to prepend to all \n        query paths. This can be useful if acessing a cluster on a host that \n        uses paths to namespace customer indexes.\n    @param {Number} [options.timeout=60000] Number of milliseconds to wait\n        before aborting a request. Be sure to increase this if you do large bulk\n        operations.\n@constructor\n**/\nfunction Client(host, options) {\n    // Allow options without host.\n    if (typeof host === 'object') {\n        options = host;\n        host    = undefined;\n    }\n\n    this.host    = host || '127.0.0.1';\n    this.options = options || {};\n\n    if(typeof this.options.port === 'undefined') {\n      this.options.port = 9200;\n    }\n    else if(this.options.port === null) {\n      this.options.port = null;\n    }\n    this.options.protocol || (this.options.protocol = 'http');\n    this.options.timeout || (this.options.timeout = 60000);\n    this.options.basePath || (this.options.basePath = null);\n\n    this._indexCache = {};\n}\n\nClient.prototype = {\n    // -- Protected Properties -------------------------------------------------\n\n    /**\n    Search options that must be passed as query parameters instead of in the\n    request body.\n\n    @property _SEARCH_PARAMS\n    @type {String[]}\n    @protected\n    @final\n    **/\n    _SEARCH_PARAMS: [\n        'preference', 'routing', 'scroll', 'scroll_id', 'search_type', 'timeout', 'ignore_indices'\n    ],\n\n    // -- Public Properties ----------------------------------------------------\n\n    /**\n    Base URL for this client, of the form \"http://host:port\".\n\n    @property baseUrl\n    @type {String}\n    **/\n    get baseUrl() {\n        var baseUrl = this.options.protocol + '://' +\n            (this.options.auth ? this.options.auth + '@' : '') +\n            this.host;\n\n        if(this.options.port !== null) {\n          baseUrl = baseUrl + ':' + this.options.port;\n        }\n\n        if(this.options.basePath !== null) {\n          baseUrl = baseUrl + this.options.basePath;\n        }\n        \n        return baseUrl;\n    },\n\n    /**\n    Port number for this client.\n\n    @property port\n    @type {Number}\n    **/\n    get port() {\n        return this.options.port;\n    },\n\n    // -- Public Methods -------------------------------------------------------\n\n    /**\n    Performs multiple document create/index/delete operations in a single request.\n\n    See `Index.bulk()` for detailed usage instructions.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/bulk.html)\n\n    @example\n\n        client.bulk([\n            {create: {index: 'blog', type: 'post', id: '1', data: {\n                title: 'Hello',\n                body : 'Welcome to my stupid blog.'\n            }}},\n\n            {index: {index: 'blog', type: 'post', id: '2', data: {\n                title: 'Breaking news',\n                body : 'Today I ate a sandwich.'\n            }}},\n\n            {delete: {index: 'blog', type: 'post', id: '42'}}\n        ], function (err, res) {\n            // ...\n        });\n\n    @method bulk\n    @param {Object[]} operations Array of operations to perform. See\n        `Index.bulk()` for a description of the expected object format.\n    @param {Object} [options] Options. See `Index.bulk()` for details.\n    @param {Function} [callback] Callback function.\n        @param {Error|null} callback.err Error, or `null` on success.\n        @param {Object} callback.res ElasticSearch response data.\n    @see Index.bulk\n    **/\n    bulk: wrapStaticIndexMethod('bulk'),\n\n    /**\n    Get the number of matches for a query\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/count.html)\n\n    @method count\n    @param {Object} options the options object\n      @param {String} [options.index] Index name.\n      @param {String} [options.type] type Type name.\n      @param {String} [otions.query] Query to get the number of match for.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @static\n    @see Index.count\n    **/\n    count: function (options, callback) {\n        var url   = '',\n            hasOptions;\n        if (typeof options === 'function') {\n            callback = options;\n            options  = {};\n        }\n        if(typeof callback !== 'function'){\n          var err =  new Error(\"callback is not a function\");\n          var stack = err.stack;\n          throw err;\n        }\n\n        // Create a copy of options so we can modify it.\n        options = util.merge(options || {});\n\n\n        if (options.index) {\n            url = '/' + encode(Array.isArray(options.index) ?\n                options.index.join(',') : options.index);\n\n            delete options.index;\n        }\n\n        // If a query is provided and it's a string, automatically turn it into\n        // a query_string query.\n        if (typeof options.query === 'string') {\n            options = {query_string: {query: options.query}};\n        }\n\n        if (options.type) {\n            if (!url) {\n                url = '/_all';\n            }\n\n            url += '/' + encode(Array.isArray(options.type) ?\n                options.type.join(',') : options.type);\n\n            delete options.type;\n        }\n\n        hasOptions = !!Object.keys(options).length;\n        url += '/_count';\n        options.curlDebug = true;\n        var myOptions = { method: hasOptions ? 'POST' : 'GET'};\n        if(hasOptions){\n          myOptions.json = options;\n        }\n        this._request(url, myOptions, function (err, res) {\n            if (err) { \n              return callback(err, null, res), undefined; \n            }\n            if(res._shards.failed > 0){\n              return callback(new Error(res._shards.failures.reason), null, res), undefined;\n            }\n            return callback(null, res.count, res);\n        });\n    },\n\n    /**\n    Creates a new index.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-create-index.html)\n\n    @method createIndex\n    @param {String} name Name of the new index.\n    @param {Object} options Index options (see ElasticSearch docs for details).\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Index} callback.index Index instance for the newly created index.\n      @param {Object} callback.data ElasticSearch response data.\n    @see Index.create\n    **/\n    createIndex: wrapStaticIndexMethod('create'),\n\n    /**\n    Deletes a document from the specified index. See `Index.delete()` for the\n    complete list of supported options.\n\n    @method delete\n    @param {String} index Index name.\n    @param {String} type Type name.\n    @param {String} id Document id to delete.\n    @param {Object} [options] Delete options.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response.\n    @see Index.delete\n    **/\n    delete: wrapIndexMethod('delete'),\n\n    /**\n    Deletes the specified index or indices. If no indices are specified, **all**\n    indices on the server will be deleted.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-delete-index.html)\n\n    @method deleteIndex\n    @param {String|String[]} [names] Name of the index to delete, or an array of\n        names to delete multiple indices. If omitted, **all** indices will be\n        deleted.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.data ElasticSearch response data.\n    @see Index.deleteIndex\n    **/\n    deleteIndex: wrapStaticIndexMethod('delete'),\n\n    /**\n    Gets a document from the specified index based on its id.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/get.html)\n\n    @method get\n    @param {String} name Index name.\n    @param {String} id Document id.\n    @param {Object} [options] Options.\n      @param {String|String[]} [options.fields] Document field name or array of\n          field names to retrieve. By default, all fields are retrieved.\n      @param {Boolean} [options.ignoreMissing=false] If `true`, an error will\n          not be returned if the index, type, or document do not exist. Instead,\n          a `null` document will be returned.\n      @param {String} [options.preference] Controls which shard replicas the\n          request should be executed on. By default, the operation will be\n          randomized between the shard replicas. See the ElasticSearch docs for\n          possible values.\n      @param {Boolean} [options.realtime=true] Whether or not to use realtime\n          GET. See the ElasticSearch docs for details.\n      @param {Boolean} [options.refresh=false] If `true`, the relevant shard\n          will be refreshed before the get operation to ensure that it's\n          searchable. This may cause heavy server load, so use with caution.\n      @param {String} [options.routing] Value that determines what shard this\n          document will be routed to. If not specified, a hash of the document's\n          id will be used. Note that an incorrectly routed get operation will\n          fail, so it's best to leave this alone unless you know your business.\n      @param {String} [options.type=\"_all\"] If specified, the get operation will\n          be limited to documents of this type.\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object|null} callback.doc Retrieved document or document fields,\n          or `null` if the document was not found and `options.ignoreMissing` is\n          `true`.\n      @param {Object} callback.res Full ElasticSearch response data.\n    @see Index.get\n    **/\n    get: wrapIndexMethod('get'),\n\n    /**\n    Gets an Index instance for interacting with the specified ElasticSearch\n    index.\n\n    @example\n\n        var client = new require('elastical').Client(),\n            tweets = client.getIndex('tweets');\n\n    @method getIndex\n    @param {String} name Index name.\n    @return {Index} Index instance.\n    @see Index\n    **/\n    getIndex: function (name) {\n        return this._indexCache[name] ||\n            (this._indexCache[name] = new Index(this, name));\n    },\n\n    /**\n    Gets mapping definitions for the specified type within the specified index.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-put-mapping.html)\n\n    @method getMapping\n    @param {String|String[]} names Index name or array of names.\n    @param {String} type Document type. If omitted, mappings for all type are returned.\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @static\n    @see Client.getMapping\n    **/\n    getMapping: wrapStaticIndexMethod('getMapping'),\n\n    /**\n    Gets settings for the specified index/indices.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-get-settings.html)\n\n    @method getSettings\n    @param {String|String[]} names Index name or array of names.\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @see Index.getSettings\n    **/\n    getSettings: wrapStaticIndexMethod('getSettings'),\n\n    /**\n    Update settings for the specified index/indices.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-update-settings/)\n\n    @method updateSettings\n    @param {String|String[]} index Index name or array of names. If not specified,\n        it will be applied to all indices\n    @param {Object} settings Settings. See ElasticSearch docs for details.\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @see Index.updateSettings\n    **/\n    updateSettings: wrapStaticIndexMethod('updateSettings'),\n\n    /**\n     Apply aliases actions.\n\n     [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-aliases.html)\n\n     @method applyAliasesActions\n     @param {Object[]} actions Aliases actions.\n     @param {Function} callback Callback function.\n     @param {Error|null} callback.err Error, or `null` on success.\n     @param {Object} callback.res ElasticSearch response data.\n     @see Index.applyAliasesActions\n     **/\n    applyAliasesActions: wrapStaticIndexMethod('applyAliasesActions'),\n\n    /**\n     Get aliases.\n\n     [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-aliases.html)\n\n     @method getAliases\n     @param {String|String[]|null} names Index name or array of names.\n     @param {Function} callback Callback function.\n     @param {Error|null} callback.err Error, or `null` on success.\n     @param {Object} callback.res ElasticSearch response data.\n     @see Index.getAliases\n     **/\n    getAliases: wrapStaticIndexMethod('getAliases'),\n\n/**\n    Adds a document to the specified index.\n\n    If the specified index doesn't exist, it will be created.\n\n    If a document already exists in that index with the specified _type_ and\n    _id_, it will be updated. Otherwise, a new document will be created.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/index_.html)\n\n    @example\n\n        client.index('blog', 'post', {\n            title  : \"Welcome to my stupid blog\",\n            content: \"This is the first and last time I'll post anything.\",\n            tags   : ['welcome', 'first post', 'last post'],\n            created: Date.now()\n        }, function (err, res) {\n            if (err) { throw err; }\n            console.log('Indexed a blog post');\n        });\n\n    @method index\n    @param {String} index Index name.\n    @param {String} type Document type.\n    @param {Object} doc Document data to index.\n    @param {Object} [options] Options.\n      @param {String} [options.consistency=\"quorum\"] Write consistency to use\n          for this indexing operation. Permitted values are \"one\", \"quorum\" and\n          \"all\". See the ElasticSearch docs for details.\n      @param {Boolean} [options.create=false] Only create the document if it\n          doesn't already exist.\n      @param {String} [options.id] Document id. One will be automatically\n          generated if not specified.\n      @param {String} [options.parent] Parent document id.\n      @param {String} [options.percolate] Percolation query to check against\n          this document. See the ElasticSearch docs for details.\n      @param {Boolean} [options.refresh=false] If `true`, the document will be\n          made searchable immediately after it is indexed.\n      @param {String} [options.replication=\"sync\"] Replication mode for this\n          indexing operation. Maybe be set to \"sync\" or \"async\".\n      @param {String} [options.routing] Value that determines what shard this\n          document will be routed to. If not specified, a hash of the document's\n          id will be used.\n      @param {String} [options.timeout=\"1m\"] How long to wait for the primary\n          shard to become available to index this document before aborting. See\n          the ElasticSearch docs for details. This should be a value like \"5m\"\n          (5 minutes) or \"15s\" (15 seconds).\n      @param {Number} [options.version] Document version to create/update. If\n          this is set and `options.version_type` is not set,\n          `options.version_type` will automatically be set to \"external\".\n      @param {String} [options.version_type=\"internal\"] Version type (either\n          \"internal\" or \"external\"). See the ElasticSearch docs for details.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @see Index.index\n    **/\n    index: wrapIndexMethod('index'),\n\n    /**\n    Checks whether the specified index or indices exist.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-indices-exists.html)\n\n    @method indexExists\n    @param {String|String[]} names Index name or array of names to check.\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Boolean} callback.exists `true` if all specified indices exist,\n        `false` otherwise.\n    @see Index.exists\n    **/\n    indexExists: wrapStaticIndexMethod('exists'),\n\n    /**\n    Multi GET API allows to get multiple documents\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/multi-get.html)\n\n    @method multiGet\n    @param {String|null} index optional Index name.\n    @param {String|null} type optional document type.\n    @param {Object} data either docs or ids\n      @param {Object[]} [data.docs] docs to query (can include _index, _type, _id, fields)\n      @param {String[]} [data.ids] ids to query\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @see Index.multiGet\n    **/\n    multiGet: wrapStaticIndexMethod('multiGet'),\n\n    /**\n    Registers a mapping definition for the specified type within the specified\n    index or indices.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-put-mapping.html)\n\n    @method putMapping\n    @param {String|String[]} [names] Index name or array of names to define the\n        mapping within. If not specified, it will be defined in all indices.\n    @param {String} type Document type.\n    @param {Object} [mapping] Mapping definition. See the [ElasticSearch\n        docs](http://www.elasticsearch.org/guide/reference/mapping/) for\n        an overview.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @static\n    @see Client.putMapping\n    **/\n    putMapping: wrapStaticIndexMethod('putMapping'),\n\n    /**\n    Refreshes the specified index or indices.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-refresh.html)\n\n    @method refresh\n    @param {String|String[]} [names] Index name or array of names to refresh. If\n        not specified, all indices will be refreshed.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @see Index.refresh\n    **/\n    refresh: wrapStaticIndexMethod('refresh'),\n\n    /**\n    Analyze\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-analyze.html)\n\n    @method analyze\n    @param {String} text Text to analyze\n    @param {Object} [options] Options. See ElasticSearch docs for details.\n        @param {String} [options.index=\"indexname\"] Specify indexname to use a specific\n            index analyzer\n        @param {String} [options.analyzer=\"standard\"] Analyzer to use for analysis\n        @param {String} [options.tokenizer=\"keyword\"] Tokenizer to use for anaysis when\n            using a custom transient anayzer\n        @param {String} [options.field=\"obj1.field1\"] Use the analyzer configured in\n            the mapping for this field\n    @param {Function} [callback] Callback function.\n        @param {Error|null} callback.err Error, or `null` on success.\n        @param {Object} callback.res ElasticSearch response data.\n    @static\n    @see Index.analyze\n    **/\n\n    analyze: wrapStaticIndexMethod('analyze'),\n\n    /**\n    Searches for documents matching the given query.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/search/)\n\n    @example\n\n        var client = new require('elastical').Client();\n\n        client.search({query: 'pie'}, function (err, results) {\n            if (err) { throw err; }\n            console.log(results);\n        });\n\n    @method search\n    @param {Object} [options] Search options. Technically this argument is\n        optional, but you'll almost always want to provide at least a query.\n\n      @param {Object|String} [options.query] Search query. This can be a simple\n          string (in which case a \"query_string\" search will be performed) or a\n          full query object. See the [ElasticSearch Query DSL docs](http://www.elasticsearch.org/guide/reference/query-dsl/)\n          for details.\n      @param {Boolean} [options.explain=false] If `true`, results will include\n          an explanation of how the score was computed for each hit.\n      @param {Object} [options.facets] Facets to aggregate by. See the\n          [ElasticSearch facets docs](http://www.elasticsearch.org/guide/reference/api/search/facets/)\n          for details.\n      @param {String|String[]} [options.fields] Document field name or array of\n          field names to retrieve. By default, all fields are retrieved.\n      @param {Object} [options.filter] Result filter. See the [ElasticSearch\n          filtering docs](http://www.elasticsearch.org/guide/reference/api/search/filter.html)\n          for details.\n      @param {Number} [options.from=0] Return results starting at this offset.\n      @param {Object} [options.highlight] Result highlighting options. See the\n          [ElasticSearch highlighting docs](http://www.elasticsearch.org/guide/reference/api/search/highlighting.html)\n          for details.\n      @param {String|String[]} [options.index] Index name or array of index\n          names to search. By default all indices will be searched.\n      @param {Object} [options.indices_boost] Index boost options. See the\n          [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/search/index-boost.html)\n          for details.\n      @param {Number} [options.min_score] If specified, documents with a score\n          lower than this will be filtered out.\n      @param {String} [options.preference] Controls which shard replicas the\n          request should be executed on. By default, the operation will be\n          randomized between the shard replicas. See the [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/search/preference.html)\n          for possible values.\n      @param {String} [options.routing] Value that determines what shard this\n          search will be routed to.\n      @param {Object} [options.script_fields] Script expressions to evaluate for\n          specific fields. See the [ElasticSearch script fields docs](http://www.elasticsearch.org/guide/reference/api/search/script-fields.html)\n          for details.\n      @param {String} [options.scroll] Scroll timeout. If specified, nodes that\n          participate in this search will maintain resources for this query\n          until the timeout expires. See the [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/search/scroll.html)\n          for details.\n      @param {String} [options.scroll_id] Scroll id to use for this request.\n      @param {String} [options.search_type] Search operation type to use. May be\n          one of \"query_and_fetch\", \"query_then_fetch\", \"dfs_query_and_fetch\",\n          \"dfs_query_then_fetch\", \"count\", or \"scan\". See the [ElasticSearch\n          docs](http://www.elasticsearch.org/guide/reference/api/search/search-type.html)\n          for details.\n      @param {Number} [options.size=10] Return this many results.\n      @param {Object} [options.sort] Sort options. See the [ElasticSearch sort\n          docs](http://www.elasticsearch.org/guide/reference/api/search/sort.html)\n          for details.\n      @param {String} [options.timeout] Timeout after which the search will be\n          aborted. Any hits that have been gathered before the timeout is\n          reached will be returned. Default is no timeout.\n      @param {Boolean} [options.track_scores=false] Whether or not to compute\n          scores when sorting by a field.\n      @param {String|String[]} [options.type] Type name or array of type names\n          to search. By default all types will be searched.\n      @param {Boolean} [options.version=false] If `true`, a version number will\n          be returned for each hit.\n\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.results Search results.\n      @param {Object} callback.res Full ElasticSearch response data.\n    **/\n    search: function (options, callback) {\n        var query = [],\n            url   = '',\n            hasOptions;\n\n        if (typeof options === 'function') {\n            callback = options;\n            options  = {};\n        }\n        var useScrollingEndpoint = (options.scroll_id != null);\n        // Create a copy of options so we can modify it.\n        options = util.merge(options || {});\n\n        // Some options must be passed as query parameters. Find those options\n        // and move them into the query param array.\n        this._SEARCH_PARAMS.forEach(function (name) {\n            var value = options[name];\n\n            if (typeof value !== 'undefined') {\n                if (value === true || value === false) {\n                    query.push(encode(name) + '=' + (value ? '1' : '0'));\n                } else {\n                    query.push(encode(name) + '=' + encode(value));\n                }\n\n                delete options[name];\n            }\n        });\n\n        if (options.fields) {\n            options.fields = Array.isArray(options.fields) ? options.fields :\n                [options.fields];\n        }\n\n        if (options.index) {\n            url = '/' + encode(Array.isArray(options.index) ?\n                options.index.join(',') : options.index);\n\n            delete options.index;\n        }\n\n        // If a query is provided and it's a string, automatically turn it into\n        // a query_string query.\n        if (typeof options.query === 'string') {\n            options.query = {query_string: {query: options.query}};\n        }\n\n        if (options.type) {\n            if (!url) {\n                url = '/_all';\n            }\n\n            url += '/' + encode(Array.isArray(options.type) ?\n                options.type.join(',') : options.type);\n\n            delete options.type;\n        }\n\n        hasOptions = !!Object.keys(options).length;\n\n        url += '/_search';\n\n        if(useScrollingEndpoint){\n          url += '/scroll';\n        }\n\n        if (query.length) {\n            url += '?' + query.join('&');\n        }\n\n        this._request(url, {\n            method: hasOptions ? 'POST' : 'GET',\n            json  : hasOptions ? options : {}\n        }, function (err, res) {\n            if (err) { return callback(err, null, res), undefined; }\n            callback(null, res.hits, res);\n        });\n    },\n    \n    /**\n    Provide statistics on different operations happening on an index.\n    By default, docs, store, and indexing, get, and search stats are returned.\n    \n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-stats.html)\n\n    @example\n\n        var client = new require('elastical').Client();\n\n        client.stat({index: 'blog'}, function (err, results) {\n            if (err) { throw err; }\n            console.log(results);\n        });\n\n    @method stats\n    @param {Object} [options] Stats options. Technically this argument is\n        optional, but you'll almost always want to provide at least an index.\n      @param {String|String[]} [options.index] Index name or array of index\n          names to display stats on. By default global stats will be displayed.\n      @param (String|String[]) [options.types] Comma separated list of types to provide document type level stats.\n      @param {Boolean} [options.docs=true] The number of docs / deleted docs.\n      @param {Boolean} [options.store=true] The size of the index.\n      @param {Boolean} [options.indexing=true] Indexing statistics.\n      @param {Boolean} [options.get=true] Get statistics, including missing stats.\n      @param {Boolean} [options.search=true] Search statistics.\n      @param {Boolean} [options.warmer=false] Warmer statistics.\n      @param {Boolean} [options.merge=false] merge stats.\n      @param {Boolean} [options.flush=false] flush stats.\n      @param {Boolean} [options.refresh=false] refresh stats.\n      @param {Boolean} [options.clear=false] Clears all the flags (first).\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    **/\n    stats: function (options, callback) {\n      var query = [],\n          url = '',\n          hasOptions;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      //Create a copy of options so we can modify it.\n      options = util.merge(options || {});\n\n      if (options.index) {\n        url = '/' + encode(Array.isArray(options.index) ?\n          options.index.join(',') : options.index);\n\n        delete options.index;\n        //Look for types only if there is an index\n        if (options.types) {\n          query.push(encode('types') + '=' + encode(Array.isArray(options.types) ?\n            options.types.join(',') : options.types));\n        }\n        delete options.types;\n      }\n\n      url += '/_stats';  \n\n      util.each(options, function (value, name) {\n          if (value === true || value === false) {\n              value = value ? '1' : '0';\n          }\n\n          query.push(encode(name) + '=' + encode(value));\n      });\n      \n      if (query.length) {\n        url += '?' + query.join('&');\n      }\n      \n      this._request(url, {\n          method: 'GET'\n      }, function (err, res) {\n        if(err) { return callback(err, null, res), undefined; }\n        callback(null, res);\n      });\n    },\n    \n    // TODO: percolate, delete by query, more like this\n    /**\n    Registers a percolator for the given index or modifies the existing percolator\n    if one with the name already exists\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/pecolator/)\n\n    @example\n        var put =   {\n                        \"query\" : {\n                            \"text\" : {\n                                \"hashtags\" : {\n                                    \"query\" : 'blah blah blah ',\n                                    \"operator\" : \"or\"\n                                }\n                            }\n                        }\n                    };\n        client.percolator('tweets', 'mypercolator', query, function (err, res) {\n            if (err) { throw err; }\n            console.log(results);\n        });\n    @method setPercolator\n    @param {String|String[]} index Index name or array of index\n          names to register the percolator.\n    @param {String} percolator The identifier string of the percolator.\n            This identifier is returned when a document matches\n            the query in the percolator, either through percolate operation or\n            through index opertation.\n    @param {Object|String} query Search query. Afull query object.\n        See the [ElasticSearch Query DSL docs](http://www.elasticsearch.org/guide/reference/query-dsl/)\n        for details.\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res Full ElasticSearch response data.\n    */\n    setPercolator: wrapIndexMethod('setPercolator'),\n\n    /**\n     * Retrieve the percolator doc\n     *\n     * @example\n     *\n     *  client.getPercolator('tweets', 'mypercolator', function (err, results) {\n     *      if (err) { throw err; }\n     *      console.log(results);\n     *  });\n     *\n     *  @param {String} index  The index name to which the percolator is registered\n     *  @param {String} percolator The name of the percolator\n     *  @param {Function} callback Callback function.\n     *      @param {Error|null} callback.err Error, or `null` on success.\n     *      @param {Object} callback.doc  Percolator document.\n     *      @param {Object} callback.res Full ElasticSearch response data.\n     */\n    getPercolator: wrapIndexMethod('getPercolator'),\n\n    /**\n     * Test if a given doc matches a percolator for\n     * the given index and document type\n     * @example\n     *      client.perolate('tweets', 'tweet', {}, function(err, res){\n     *          if(err){ throw err; }\n     *          console.log(res);\n     *      });\n     *  @param {String} index The index name to which the document should be\n     *      checked for matching percolators\n     *  @param {String} type The type name of the document\n     *  @param {Object} doc The document object which the registered percolators\n     *      are matched against\n     *  @param {Function} callback Callback function.\n     *      @param {Error|null} callback.err Error, or `null` on success.\n     *      @param {Object} callback.res Full ElasticSearch response data.\n     */\n    percolate: wrapIndexMethod('percolate'),\n\n    /**\n     * Delete a registered percolator for the given index or indicies\n     * @example\n     *      client.deletePercolator('tweets', 'mypercolator', function(err, res){\n     *          if(err){ throw err;}\n     *          console.log(res);\n     *      });\n     * @param {String|String[]} index Index name or array of index names\n     * @param {String} percolator Name of the percolator to delete\n     * @param {Function} callback Callback function.\n     *      @param {Error|null} callback.err Error, or `null` on success.\n     *      @param {Object} callback.res Full ElasticSearch response data.\n     */\n    deletePercolator: wrapIndexMethod('deletePercolator'),\n\n\n    /**\n    Registers a river with the cluster.\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/river/)\n\n    @method putRiver\n    @param {String} name A name for this river.\n    @param {Object} config The river configuration.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @static\n    **/\n    putRiver: wrapStaticIndexMethod('putRiver'),\n\n    /**\n    Gets river config from the cluster.\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/river/)\n\n    @method getRiver\n    @param {Client} client Client instance.\n    @param {String} name A name for this river.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @static\n    **/\n    getRiver: wrapStaticIndexMethod('getRiver'),\n\n    /**\n    Deletes a river config from the cluster.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/river/)\n\n    @method deleteRiver\n    @param {Client} client Client instance.\n    @param {String} name A name for this river.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @static\n    **/\n    deleteRiver: wrapStaticIndexMethod('deleteRiver'),\n\n    // -- Protected Methods ----------------------------------------------------\n\n    /**\n    Makes an HTTP request using the `request` module.\n\n    @method _request\n    @param {String} path Request path.\n    @param {Object} [options] Request options.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object|Buffer|String} callback.body Response body (parsed as JSON\n          if possible).\n    @protected\n    **/\n    _request: function (path, options, callback) {\n        var url = this.baseUrl + path;\n\n        if (typeof options === 'function') {\n            callback = options;\n            options  = {};\n        }\n\n        // Callback is optional.\n        callback || (callback = noop);\n\n        options = util.merge(options);\n        options.uri = url;\n\n        [ 'timeout',\n          'pool',\n          'agent',\n          'headers',\n          'followRedirect',\n          'followAllRedirects',\n          'proxy',\n          'oauth',\n          'strictSSL',\n          'jar'].forEach(function(key){\n          if(this.options[key] == null) return\n          options[key] || (options[key] = this.options[key]);\n        }, this);\n\n        // Write executable curl commands to stderr for easier debugging when\n        // this client's curlDebug option is true.\n        if (this.options.curlDebug) {\n            curlDebug(options);\n        }\n\n        // Provide a testing hook to allow inspection of the request options\n        // without actually sending a request.\n        if (this._testHook) {\n            return this._testHook(null, options), undefined;\n        }\n        request(url, options, function (err, res, body) {\n            if (err) { return callback(err), undefined; }\n\n            // The request module will automatically try to parse the\n            // response as JSON if `options.json` is truthy and the response\n            // has an application/json content-type, but it currently fails\n            // on content-types with charset suffixes, so it can't be relied\n            // upon.\n            //\n            // See https://github.com/mikeal/request/commit/68c17f6c9a3d7217368b3b8bc61203e6a14eb4f0\n            if (typeof body === 'string' || body instanceof Buffer) {\n                body = body.toString('utf8');\n\n                try {\n                    body = JSON.parse(body);\n                } catch (ex) {}\n            }\n\n            if (res.statusCode < 200 || res.statusCode > 299) {\n                callback(Error((body && body.error) || 'HTTP ' + res.statusCode),\n                    body || {});\n                return;\n            }\n\n            callback(null, body || {});\n            return;\n        });\n    }\n};\n\n/**\nAlias for index().\n\n@method set\n@see index\n**/\nClient.prototype.set = Client.prototype.index;\n\nmodule.exports = Client;\n\n// -- Private Functions --------------------------------------------------------\nfunction noop() {}\n\nfunction curlDebug(options) {\n    var command = 'curl -X' + (options.method || 'GET');\n\n    command += \" '\" + options.uri + \"'\";\n\n    if (options.body) {\n        command += \" --data-binary '\" + options.body + \"'\";\n    } else if (options.json) {\n        command += \" -d '\" + JSON.stringify(options.json, null, 2) + \"'\";\n    }\n\n    process.stdout.write(command + '\\n');\n}\n\nfunction wrapIndexMethod(methodName) {\n    return function (indexName) {\n        var args  = Array.prototype.slice.call(arguments, 1),\n            index = this.getIndex(indexName);\n\n        return index[methodName].apply(index, args);\n    };\n}\n\nfunction wrapStaticIndexMethod(methodName) {\n    return function () {\n        var args = Array.prototype.slice.call(arguments);\n\n        args.unshift(this);\n        return Index[methodName].apply(Index, args);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-elastical/node_modules/elastical/node_modules/request/main.js":"// Copyright 2010-2012 Mikeal Rogers\n//\n//    Licensed under the Apache License, Version 2.0 (the \"License\");\n//    you may not use this file except in compliance with the License.\n//    You may obtain a copy of the License at\n//\n//        http://www.apache.org/licenses/LICENSE-2.0\n//\n//    Unless required by applicable law or agreed to in writing, software\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//    See the License for the specific language governing permissions and\n//    limitations under the License.\n\nvar http = require('http')\n  , https = false\n  , tls = false\n  , url = require('url')\n  , util = require('util')\n  , stream = require('stream')\n  , qs = require('querystring')\n  , mimetypes = require('./mimetypes')\n  , oauth = require('./oauth')\n  , uuid = require('./uuid')\n  , ForeverAgent = require('./forever')\n  , Cookie = require('./vendor/cookie')\n  , CookieJar = require('./vendor/cookie/jar')\n  , cookieJar = new CookieJar\n  , tunnel = require('./tunnel')\n  ;\n  \nif (process.logging) {\n  var log = process.logging('request')\n}\n\ntry {\n  https = require('https')\n} catch (e) {}\n\ntry {\n  tls = require('tls')\n} catch (e) {}\n\nfunction toBase64 (str) {\n  return (new Buffer(str || \"\", \"ascii\")).toString(\"base64\")\n}\n\n// Hacky fix for pre-0.4.4 https\nif (https && !https.Agent) {\n  https.Agent = function (options) {\n    http.Agent.call(this, options)\n  }\n  util.inherits(https.Agent, http.Agent)\n  https.Agent.prototype._getConnection = function(host, port, cb) {\n    var s = tls.connect(port, host, this.options, function() {\n      // do other checks here?\n      if (cb) cb()\n    })\n    return s\n  }\n}\n\nfunction isReadStream (rs) {\n  if (rs.readable && rs.path && rs.mode) {\n    return true\n  }\n}\n\nfunction copy (obj) {\n  var o = {}\n  Object.keys(obj).forEach(function (i) {\n    o[i] = obj[i]\n  })\n  return o\n}\n\nvar isUrl = /^https?:/\n\nvar globalPool = {}\n\nfunction Request (options) {\n  stream.Stream.call(this)\n  this.readable = true\n  this.writable = true\n\n  if (typeof options === 'string') {\n    options = {uri:options}\n  }\n  \n  var reserved = Object.keys(Request.prototype)\n  for (var i in options) {\n    if (reserved.indexOf(i) === -1) {\n      this[i] = options[i]\n    } else {\n      if (typeof options[i] === 'function') {\n        delete options[i]\n      }\n    }\n  }\n  options = copy(options)\n  \n  this.init(options)\n}\nutil.inherits(Request, stream.Stream)\nRequest.prototype.init = function (options) {\n  var self = this\n  \n  if (!options) options = {}\n  \n  if (!self.pool) self.pool = globalPool\n  self.dests = []\n  self.__isRequestRequest = true\n  \n  // Protect against double callback\n  if (!self._callback && self.callback) {\n    self._callback = self.callback\n    self.callback = function () {\n      if (self._callbackCalled) return // Print a warning maybe?\n      self._callback.apply(self, arguments)\n      self._callbackCalled = true\n    }\n    self.on('error', self.callback.bind())\n    self.on('complete', self.callback.bind(self, null))\n  }\n\n  if (self.url) {\n    // People use this property instead all the time so why not just support it.\n    self.uri = self.url\n    delete self.url\n  }\n\n  if (!self.uri) {\n    throw new Error(\"options.uri is a required argument\")\n  } else {\n    if (typeof self.uri == \"string\") self.uri = url.parse(self.uri)\n  }\n  if (self.proxy) {\n    if (typeof self.proxy == 'string') self.proxy = url.parse(self.proxy)\n\n    // do the HTTP CONNECT dance using koichik/node-tunnel\n    if (http.globalAgent && self.uri.protocol === \"https:\") {\n      self.tunnel = true\n      var tunnelFn = self.proxy.protocol === \"http:\"\n                   ? tunnel.httpsOverHttp : tunnel.httpsOverHttps\n\n      var tunnelOptions = { proxy: { host: self.proxy.hostname\n                                   , port: +self.proxy.port \n                                   , proxyAuth: self.proxy.auth }\n                          , ca: this.ca }\n\n      self.agent = tunnelFn(tunnelOptions)\n      self.tunnel = true\n    }\n  }\n\n  self._redirectsFollowed = self._redirectsFollowed || 0\n  self.maxRedirects = (self.maxRedirects !== undefined) ? self.maxRedirects : 10\n  self.followRedirect = (self.followRedirect !== undefined) ? self.followRedirect : true\n  self.followAllRedirects = (self.followAllRedirects !== undefined) ? self.followAllRedirects : false;\n  if (self.followRedirect || self.followAllRedirects)\n    self.redirects = self.redirects || []\n\n  self.headers = self.headers ? copy(self.headers) : {}\n\n  self.setHost = false\n  if (!self.headers.host) {\n    self.headers.host = self.uri.hostname\n    if (self.uri.port) {\n      if ( !(self.uri.port === 80 && self.uri.protocol === 'http:') &&\n           !(self.uri.port === 443 && self.uri.protocol === 'https:') )\n      self.headers.host += (':'+self.uri.port)\n    }\n    self.setHost = true\n  }\n  \n  self.jar(self._jar || options.jar)\n\n  if (!self.uri.pathname) {self.uri.pathname = '/'}\n  if (!self.uri.port) {\n    if (self.uri.protocol == 'http:') {self.uri.port = 80}\n    else if (self.uri.protocol == 'https:') {self.uri.port = 443}\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.port = self.proxy.port\n    self.host = self.proxy.hostname\n  } else {\n    self.port = self.uri.port\n    self.host = self.uri.hostname\n  }\n\n  self.clientErrorHandler = function (error) {\n    if (self._aborted) return\n    \n    if (self.setHost) delete self.headers.host\n    if (self.req._reusedSocket && error.code === 'ECONNRESET'\n        && self.agent.addRequestNoreuse) {\n      self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }\n      self.start()\n      self.req.end()\n      return\n    }\n    if (self.timeout && self.timeoutTimer) {\n      clearTimeout(self.timeoutTimer)\n      self.timeoutTimer = null\n    }\n    self.emit('error', error)\n  }\n\n  if (options.form) {\n    self.form(options.form)\n  }\n\n  if (options.oauth) {\n    self.oauth(options.oauth)\n  }\n\n  if (self.uri.auth && !self.headers.authorization) {\n    self.headers.authorization = \"Basic \" + toBase64(self.uri.auth.split(':').map(function(item){ return qs.unescape(item)}).join(':'))\n  }\n  if (self.proxy && self.proxy.auth && !self.headers['proxy-authorization'] && !self.tunnel) {\n    self.headers['proxy-authorization'] = \"Basic \" + toBase64(self.proxy.auth.split(':').map(function(item){ return qs.unescape(item)}).join(':'))\n  }\n\n  if (options.qs) self.qs(options.qs)\n\n  if (self.uri.path) {\n    self.path = self.uri.path\n  } else {\n    self.path = self.uri.pathname + (self.uri.search || \"\")\n  }\n\n  if (self.path.length === 0) self.path = '/'\n\n  if (self.proxy && !self.tunnel) self.path = (self.uri.protocol + '//' + self.uri.host + self.path)\n\n  if (options.json) {\n    self.json(options.json)\n  } else if (options.multipart) {\n    self.multipart(options.multipart)\n  }\n\n  if (self.body) {\n    var length = 0\n    if (!Buffer.isBuffer(self.body)) {\n      if (Array.isArray(self.body)) {\n        for (var i = 0; i < self.body.length; i++) {\n          length += self.body[i].length\n        }\n      } else {\n        self.body = new Buffer(self.body)\n        length = self.body.length\n      }\n    } else {\n      length = self.body.length\n    }\n    if (length) {\n      self.headers['content-length'] = length\n    } else {\n      throw new Error('Argument error, options.body.')\n    }\n  }\n\n  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol\n    , defaultModules = {'http:':http, 'https:':https}\n    , httpModules = self.httpModules || {}\n    ;\n  self.httpModule = httpModules[protocol] || defaultModules[protocol]\n\n  if (!self.httpModule) throw new Error(\"Invalid protocol\")\n\n  if (options.ca) self.ca = options.ca\n\n  if (!self.agent) {\n    if (options.agentOptions) self.agentOptions = options.agentOptions\n\n    if (options.agentClass) {\n      self.agentClass = options.agentClass\n    } else if (options.forever) {\n      self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL\n    } else {\n      self.agentClass = self.httpModule.Agent\n    }\n  }\n\n  if (self.pool === false) {\n    self.agent = false\n  } else {\n    self.agent = self.agent || self.getAgent()\n    if (self.maxSockets) {\n      // Don't use our pooling if node has the refactored client\n      self.agent.maxSockets = self.maxSockets\n    }\n    if (self.pool.maxSockets) {\n      // Don't use our pooling if node has the refactored client\n      self.agent.maxSockets = self.pool.maxSockets\n    }\n  }\n\n  self.once('pipe', function (src) {\n    if (self.ntick) throw new Error(\"You cannot pipe to this stream after the first nextTick() after creation of the request stream.\")\n    self.src = src\n    if (isReadStream(src)) {\n      if (!self.headers['content-type'] && !self.headers['Content-Type'])\n        self.headers['content-type'] = mimetypes.lookup(src.path.slice(src.path.lastIndexOf('.')+1))\n    } else {\n      if (src.headers) {\n        for (var i in src.headers) {\n          if (!self.headers[i]) {\n            self.headers[i] = src.headers[i]\n          }\n        }\n      }\n      if (src.method && !self.method) {\n        self.method = src.method\n      }\n    }\n\n    self.on('pipe', function () {\n      console.error(\"You have already piped to this stream. Pipeing twice is likely to break the request.\")\n    })\n  })\n\n  process.nextTick(function () {\n    if (self._aborted) return\n    \n    if (self.body) {\n      if (Array.isArray(self.body)) {\n        self.body.forEach(function(part) {\n          self.write(part)\n        })\n      } else {\n        self.write(self.body)\n      }\n      self.end()\n    } else if (self.requestBodyStream) {\n      console.warn(\"options.requestBodyStream is deprecated, please pass the request object to stream.pipe.\")\n      self.requestBodyStream.pipe(self)\n    } else if (!self.src) {\n      self.headers['content-length'] = 0\n      self.end()\n    }\n    self.ntick = true\n  })\n}\n\nRequest.prototype.getAgent = function () {\n  var Agent = this.agentClass\n  var options = {}\n  if (this.agentOptions) {\n    for (var i in this.agentOptions) {\n      options[i] = this.agentOptions[i]\n    }\n  }\n  if (this.ca) options.ca = this.ca\n\n  var poolKey = ''\n\n  // different types of agents are in different pools\n  if (Agent !== this.httpModule.Agent) {\n    poolKey += Agent.name\n  }\n\n  if (!this.httpModule.globalAgent) {\n    // node 0.4.x\n    options.host = this.host\n    options.port = this.port\n    if (poolKey) poolKey += ':'\n    poolKey += this.host + ':' + this.port\n  }\n\n  if (options.ca) {\n    if (poolKey) poolKey += ':'\n    poolKey += options.ca\n  }\n\n  if (!poolKey && Agent === this.httpModule.Agent && this.httpModule.globalAgent) {\n    // not doing anything special.  Use the globalAgent\n    return this.httpModule.globalAgent\n  }\n\n  // already generated an agent for this setting\n  if (this.pool[poolKey]) return this.pool[poolKey]\n\n  return this.pool[poolKey] = new Agent(options)\n}\n\nRequest.prototype.start = function () {\n  var self = this\n  \n  if (self._aborted) return\n  \n  self._started = true\n  self.method = self.method || 'GET'\n  self.href = self.uri.href\n  if (log) log('%method %href', self)\n  self.req = self.httpModule.request(self, function (response) {\n    if (self._aborted) return\n    if (self._paused) response.pause()\n    \n    self.response = response\n    response.request = self\n    response.toJSON = toJSON\n\n    if (self.httpModule === https &&\n        self.strictSSL &&\n        !response.client.authorized) {\n      var sslErr = response.client.authorizationError\n      self.emit('error', new Error('SSL Error: '+ sslErr))\n      return\n    }\n\n    if (self.setHost) delete self.headers.host\n    if (self.timeout && self.timeoutTimer) {\n      clearTimeout(self.timeoutTimer)\n      self.timeoutTimer = null\n    }  \n    \n    if (response.headers['set-cookie'] && (!self._disableCookies)) {\n      response.headers['set-cookie'].forEach(function(cookie) {\n        if (self._jar) self._jar.add(new Cookie(cookie))\n        else cookieJar.add(new Cookie(cookie))\n      })\n    }\n\n    if (response.statusCode >= 300 && response.statusCode < 400  &&\n        (self.followAllRedirects ||\n         (self.followRedirect && (self.method !== 'PUT' && self.method !== 'POST' && self.method !== 'DELETE'))) &&\n        response.headers.location) {\n      if (self._redirectsFollowed >= self.maxRedirects) {\n        self.emit('error', new Error(\"Exceeded maxRedirects. Probably stuck in a redirect loop.\"))\n        return\n      }\n      self._redirectsFollowed += 1\n\n      if (!isUrl.test(response.headers.location)) {\n        response.headers.location = url.resolve(self.uri.href, response.headers.location)\n      }\n      self.uri = response.headers.location\n      self.redirects.push(\n        { statusCode : response.statusCode\n        , redirectUri: response.headers.location \n        }\n      )\n      if (self.followAllRedirects) self.method = 'GET'\n      // self.method = 'GET'; // Force all redirects to use GET || commented out fixes #215\n      delete self.req\n      delete self.agent\n      delete self._started\n      delete self.body\n      if (self.headers) {\n        delete self.headers.host\n      }\n      if (log) log('Redirect to %uri', self)\n      self.init()\n      return // Ignore the rest of the response\n    } else {\n      self._redirectsFollowed = self._redirectsFollowed || 0\n      // Be a good stream and emit end when the response is finished.\n      // Hack to emit end on close because of a core bug that never fires end\n      response.on('close', function () {\n        if (!self._ended) self.response.emit('end')\n      })\n\n      if (self.encoding) {\n        if (self.dests.length !== 0) {\n          console.error(\"Ingoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.\")\n        } else {\n          response.setEncoding(self.encoding)\n        }\n      }\n\n      self.dests.forEach(function (dest) {\n        self.pipeDest(dest)\n      })\n\n      response.on(\"data\", function (chunk) {\n        self._destdata = true\n        self.emit(\"data\", chunk)\n      })\n      response.on(\"end\", function (chunk) {\n        self._ended = true\n        self.emit(\"end\", chunk)\n      })\n      response.on(\"close\", function () {self.emit(\"close\")})\n\n      self.emit('response', response)\n\n      if (self.callback) {\n        var buffer = []\n        var bodyLen = 0\n        self.on(\"data\", function (chunk) {\n          buffer.push(chunk)\n          bodyLen += chunk.length\n        })\n        self.on(\"end\", function () {\n          if (self._aborted) return\n          \n          if (buffer.length && Buffer.isBuffer(buffer[0])) {\n            var body = new Buffer(bodyLen)\n            var i = 0\n            buffer.forEach(function (chunk) {\n              chunk.copy(body, i, 0, chunk.length)\n              i += chunk.length\n            })\n            if (self.encoding === null) {\n              response.body = body\n            } else {\n              response.body = body.toString()\n            }\n          } else if (buffer.length) {\n            response.body = buffer.join('')\n          }\n\n          if (self._json) {\n            try {\n              response.body = JSON.parse(response.body)\n            } catch (e) {}\n          }\n          \n          self.emit('complete', response, response.body)\n        })\n      }\n    }\n  })\n\n  if (self.timeout && !self.timeoutTimer) {\n    self.timeoutTimer = setTimeout(function() {\n      self.req.abort()\n      var e = new Error(\"ETIMEDOUT\")\n      e.code = \"ETIMEDOUT\"\n      self.emit(\"error\", e)\n    }, self.timeout)\n    \n    // Set additional timeout on socket - in case if remote\n    // server freeze after sending headers\n    if (self.req.setTimeout) { // only works on node 0.6+\n      self.req.setTimeout(self.timeout, function(){\n        if (self.req) {\n          self.req.abort()\n          var e = new Error(\"ESOCKETTIMEDOUT\")\n          e.code = \"ESOCKETTIMEDOUT\"\n          self.emit(\"error\", e)\n        }\n      })\n    }\n  }\n  \n  self.req.on('error', self.clientErrorHandler)\n  \n  self.emit('request', self.req)\n}\n\nRequest.prototype.abort = function() {\n  this._aborted = true;\n  \n  if (this.req) {\n    this.req.abort()\n  }\n  else if (this.response) {\n    this.response.abort()\n  }\n  \n  this.emit(\"abort\")\n}\n\nRequest.prototype.pipeDest = function (dest) {\n  var response = this.response\n  // Called after the response is received\n  if (dest.headers) {\n    dest.headers['content-type'] = response.headers['content-type']\n    if (response.headers['content-length']) {\n      dest.headers['content-length'] = response.headers['content-length']\n    }\n  }\n  if (dest.setHeader) {\n    for (var i in response.headers) {\n      dest.setHeader(i, response.headers[i])\n    }\n    dest.statusCode = response.statusCode\n  }\n  if (this.pipefilter) this.pipefilter(response, dest)\n}\n\n// Composable API\nRequest.prototype.setHeader = function (name, value, clobber) {\n  if (clobber === undefined) clobber = true\n  if (clobber || !this.headers.hasOwnProperty(name)) this.headers[name] = value\n  else this.headers[name] += ',' + value\n  return this\n}\nRequest.prototype.setHeaders = function (headers) {\n  for (i in headers) {this.setHeader(i, headers[i])}\n  return this\n}\nRequest.prototype.qs = function (q, clobber) {\n  var base\n  if (!clobber && this.uri.query) base = qs.parse(this.uri.query)\n  else base = {}\n  \n  for (var i in q) {\n    base[i] = q[i]\n  }\n  \n  this.uri = url.parse(this.uri.href.split('?')[0] + '?' + qs.stringify(base))\n  this.url = this.uri\n  \n  return this\n}\nRequest.prototype.form = function (form) {\n  this.headers['content-type'] = 'application/x-www-form-urlencoded; charset=utf-8'\n  this.body = qs.stringify(form).toString('utf8')\n  return this\n}\nRequest.prototype.multipart = function (multipart) {\n  var self = this\n  self.body = []\n\n  if (!self.headers['content-type']) {\n    self.headers['content-type'] = 'multipart/related; boundary=frontier';\n  } else {\n    self.headers['content-type'] = self.headers['content-type'].split(';')[0] + '; boundary=frontier';\n  }\n\n  if (!multipart.forEach) throw new Error('Argument error, options.multipart.')\n\n  multipart.forEach(function (part) {\n    var body = part.body\n    if(!body) throw Error('Body attribute missing in multipart.')\n    delete part.body\n    var preamble = '--frontier\\r\\n'\n    Object.keys(part).forEach(function(key){\n      preamble += key + ': ' + part[key] + '\\r\\n'\n    })\n    preamble += '\\r\\n'\n    self.body.push(new Buffer(preamble))\n    self.body.push(new Buffer(body))\n    self.body.push(new Buffer('\\r\\n'))\n  })\n  self.body.push(new Buffer('--frontier--'))\n  return self\n}\nRequest.prototype.json = function (val) {\n  this.setHeader('content-type', 'application/json')\n  this.setHeader('accept', 'application/json')\n  this._json = true\n  if (typeof val === 'boolean') {\n    if (typeof this.body === 'object') this.body = JSON.stringify(this.body)\n  } else {\n    this.body = JSON.stringify(val)\n  }\n  return this\n}\nRequest.prototype.oauth = function (_oauth) {\n  var form\n  if (this.headers['content-type'] && \n      this.headers['content-type'].slice(0, 'application/x-www-form-urlencoded'.length) ===\n        'application/x-www-form-urlencoded' \n     ) {\n    form = qs.parse(this.body)\n  }\n  if (this.uri.query) {\n    form = qs.parse(this.uri.query)\n  } \n  if (!form) form = {}\n  var oa = {}\n  for (var i in form) oa[i] = form[i]\n  for (var i in _oauth) oa['oauth_'+i] = _oauth[i]\n  if (!oa.oauth_version) oa.oauth_version = '1.0'\n  if (!oa.oauth_timestamp) oa.oauth_timestamp = Math.floor( (new Date()).getTime() / 1000 ).toString()\n  if (!oa.oauth_nonce) oa.oauth_nonce = uuid().replace(/-/g, '')\n  \n  oa.oauth_signature_method = 'HMAC-SHA1'\n  \n  var consumer_secret = oa.oauth_consumer_secret\n  delete oa.oauth_consumer_secret\n  var token_secret = oa.oauth_token_secret\n  delete oa.oauth_token_secret\n  \n  var baseurl = this.uri.protocol + '//' + this.uri.host + this.uri.pathname\n  var signature = oauth.hmacsign(this.method, baseurl, oa, consumer_secret, token_secret)\n  \n  // oa.oauth_signature = signature\n  for (var i in form) {\n    if ( i.slice(0, 'oauth_') in _oauth) {\n      // skip \n    } else {\n      delete oa['oauth_'+i]\n    }\n  }\n  this.headers.Authorization = \n    'OAuth '+Object.keys(oa).sort().map(function (i) {return i+'=\"'+oauth.rfc3986(oa[i])+'\"'}).join(',')\n  this.headers.Authorization += ',oauth_signature=\"'+oauth.rfc3986(signature)+'\"'\n  return this\n}\nRequest.prototype.jar = function (jar) {\n  var cookies\n  \n  if (this._redirectsFollowed === 0) {\n    this.originalCookieHeader = this.headers.cookie\n  }\n  \n  if (jar === false) {\n    // disable cookies\n    cookies = false;\n    this._disableCookies = true;\n  } else if (jar) {\n    // fetch cookie from the user defined cookie jar\n    cookies = jar.get({ url: this.uri.href })\n  } else {\n    // fetch cookie from the global cookie jar\n    cookies = cookieJar.get({ url: this.uri.href })\n  }\n  \n  if (cookies && cookies.length) {\n    var cookieString = cookies.map(function (c) {\n      return c.name + \"=\" + c.value\n    }).join(\"; \")\n\n    if (this.originalCookieHeader) {\n      // Don't overwrite existing Cookie header\n      this.headers.cookie = this.originalCookieHeader + '; ' + cookieString\n    } else {\n      this.headers.cookie = cookieString\n    }\n  }\n  this._jar = jar\n  return this\n}\n\n\n// Stream API\nRequest.prototype.pipe = function (dest, opts) {\n  if (this.response) {\n    if (this._destdata) {\n      throw new Error(\"You cannot pipe after data has been emitted from the response.\")\n    } else if (this._ended) {\n      throw new Error(\"You cannot pipe after the response has been ended.\")\n    } else {\n      stream.Stream.prototype.pipe.call(this, dest, opts)\n      this.pipeDest(dest)\n      return dest\n    }\n  } else {\n    this.dests.push(dest)\n    stream.Stream.prototype.pipe.call(this, dest, opts)\n    return dest\n  }\n}\nRequest.prototype.write = function () {\n  if (!this._started) this.start()\n  this.req.write.apply(this.req, arguments)\n}\nRequest.prototype.end = function (chunk) {\n  if (chunk) this.write(chunk)\n  if (!this._started) this.start()\n  this.req.end()\n}\nRequest.prototype.pause = function () {\n  if (!this.response) this._paused = true\n  else this.response.pause.apply(this.response, arguments)\n}\nRequest.prototype.resume = function () {\n  if (!this.response) this._paused = false\n  else this.response.resume.apply(this.response, arguments)\n}\nRequest.prototype.destroy = function () {\n  if (!this._ended) this.end()\n}\n\n// organize params for post, put, head, del\nfunction initParams(uri, options, callback) {\n  if ((typeof options === 'function') && !callback) callback = options;\n  if (typeof options === 'object') {\n    options.uri = uri;\n  } else if (typeof uri === 'string') {\n    options = {uri:uri};\n  } else {\n    options = uri;\n    uri = options.uri;\n  }\n  return { uri: uri, options: options, callback: callback };\n}\n\nfunction request (uri, options, callback) {\n  if (typeof uri === 'undefined') throw new Error('undefined is not a valid uri or options object.')\n  if ((typeof options === 'function') && !callback) callback = options;\n  if (typeof options === 'object') {\n    options.uri = uri;\n  } else if (typeof uri === 'string') {\n    options = {uri:uri};\n  } else {\n    options = uri;\n  }\n\n  if (callback) options.callback = callback;\n  var r = new Request(options)\n  return r\n}\n\nmodule.exports = request\n\nrequest.defaults = function (options) {\n  var def = function (method) {\n    var d = function (uri, opts, callback) {\n      var params = initParams(uri, opts, callback);\n      for (var i in options) {\n        if (params.options[i] === undefined) params.options[i] = options[i]\n      }\n      return method(params.uri, params.options, params.callback)\n    }\n    return d\n  }\n  var de = def(request)\n  de.get = def(request.get)\n  de.post = def(request.post)\n  de.put = def(request.put)\n  de.head = def(request.head)\n  de.del = def(request.del)\n  de.cookie = def(request.cookie)\n  de.jar = def(request.jar)\n  return de\n}\n\nrequest.forever = function (agentOptions, optionsArg) {\n  var options = {}\n  if (optionsArg) {\n    for (option in optionsArg) {\n      options[option] = optionsArg[option]\n    }\n  }\n  if (agentOptions) options.agentOptions = agentOptions\n  options.forever = true\n  return request.defaults(options)\n}\n\nrequest.get = request\nrequest.post = function (uri, options, callback) {\n  var params = initParams(uri, options, callback);\n  params.options.method = 'POST';\n  return request(params.uri || null, params.options, params.callback)\n}\nrequest.put = function (uri, options, callback) {\n  var params = initParams(uri, options, callback);\n  params.options.method = 'PUT'\n  return request(params.uri || null, params.options, params.callback)\n}\nrequest.head = function (uri, options, callback) {\n  var params = initParams(uri, options, callback);\n  params.options.method = 'HEAD'\n  if (params.options.body || \n      params.options.requestBodyStream || \n      (params.options.json && typeof params.options.json !== 'boolean') || \n      params.options.multipart) {\n    throw new Error(\"HTTP HEAD requests MUST NOT include a request body.\")\n  }\n  return request(params.uri || null, params.options, params.callback)\n}\nrequest.del = function (uri, options, callback) {\n  var params = initParams(uri, options, callback);\n  params.options.method = 'DELETE'\n  return request(params.uri || null, params.options, params.callback)\n}\nrequest.jar = function () {\n  return new CookieJar\n}\nrequest.cookie = function (str) {\n  if (str && str.uri) str = str.uri\n  if (typeof str !== 'string') throw new Error(\"The cookie function only accepts STRING as param\")\n  return new Cookie(str)\n}\n\n// Safe toJSON\n\nfunction getSafe (self, uuid) {  \n  if (typeof self === 'object' || typeof self === 'function') var safe = {}\n  if (Array.isArray(self)) var safe = []\n\n  var recurse = []\n  \n  Object.defineProperty(self, uuid, {})\n  \n  var attrs = Object.keys(self).filter(function (i) {\n    if (i === uuid) return false \n    if ( (typeof self[i] !== 'object' && typeof self[i] !== 'function') || self[i] === null) return true\n    return !(Object.getOwnPropertyDescriptor(self[i], uuid))\n  })\n  \n  \n  for (var i=0;i<attrs.length;i++) {\n    if ( (typeof self[attrs[i]] !== 'object' && typeof self[attrs[i]] !== 'function') || \n          self[attrs[i]] === null\n        ) {\n      safe[attrs[i]] = self[attrs[i]]\n    } else {\n      recurse.push(attrs[i])\n      Object.defineProperty(self[attrs[i]], uuid, {})\n    }\n  }\n\n  for (var i=0;i<recurse.length;i++) {\n    safe[recurse[i]] = getSafe(self[recurse[i]], uuid)\n  }\n  \n  return safe\n}\n\nfunction toJSON () {\n  return getSafe(this, (((1+Math.random())*0x10000)|0).toString(16))\n}\n\nRequest.prototype.toJSON = toJSON\n\n","/home/travis/build/npmtest/node-npmtest-elastical/node_modules/elastical/node_modules/request/mimetypes.js":"// from http://github.com/felixge/node-paperboy\nexports.types = {\n  \"3gp\":\"video/3gpp\",\n  \"aiff\":\"audio/x-aiff\",\n  \"arj\":\"application/x-arj-compressed\",\n  \"asf\":\"video/x-ms-asf\",\n  \"asx\":\"video/x-ms-asx\",\n  \"au\":\"audio/ulaw\",\n  \"avi\":\"video/x-msvideo\",\n  \"bcpio\":\"application/x-bcpio\",\n  \"ccad\":\"application/clariscad\",\n  \"cod\":\"application/vnd.rim.cod\",\n  \"com\":\"application/x-msdos-program\",\n  \"cpio\":\"application/x-cpio\",\n  \"cpt\":\"application/mac-compactpro\",\n  \"csh\":\"application/x-csh\",\n  \"css\":\"text/css\",\n  \"deb\":\"application/x-debian-package\",\n  \"dl\":\"video/dl\",\n  \"doc\":\"application/msword\",\n  \"drw\":\"application/drafting\",\n  \"dvi\":\"application/x-dvi\",\n  \"dwg\":\"application/acad\",\n  \"dxf\":\"application/dxf\",\n  \"dxr\":\"application/x-director\",\n  \"etx\":\"text/x-setext\",\n  \"ez\":\"application/andrew-inset\",\n  \"fli\":\"video/x-fli\",\n  \"flv\":\"video/x-flv\",\n  \"gif\":\"image/gif\",\n  \"gl\":\"video/gl\",\n  \"gtar\":\"application/x-gtar\",\n  \"gz\":\"application/x-gzip\",\n  \"hdf\":\"application/x-hdf\",\n  \"hqx\":\"application/mac-binhex40\",\n  \"html\":\"text/html\",\n  \"ice\":\"x-conference/x-cooltalk\",\n  \"ico\":\"image/x-icon\",\n  \"ief\":\"image/ief\",\n  \"igs\":\"model/iges\",\n  \"ips\":\"application/x-ipscript\",\n  \"ipx\":\"application/x-ipix\",\n  \"jad\":\"text/vnd.sun.j2me.app-descriptor\",\n  \"jar\":\"application/java-archive\",\n  \"jpeg\":\"image/jpeg\",\n  \"jpg\":\"image/jpeg\",\n  \"js\":\"text/javascript\",\n  \"json\":\"application/json\",\n  \"latex\":\"application/x-latex\",\n  \"lsp\":\"application/x-lisp\",\n  \"lzh\":\"application/octet-stream\",\n  \"m\":\"text/plain\",\n  \"m3u\":\"audio/x-mpegurl\",\n  \"m4v\":\"video/mp4\",\n  \"man\":\"application/x-troff-man\",\n  \"me\":\"application/x-troff-me\",\n  \"midi\":\"audio/midi\",\n  \"mif\":\"application/x-mif\",\n  \"mime\":\"www/mime\",\n  \"mkv\":\"  video/x-matrosk\",\n  \"movie\":\"video/x-sgi-movie\",\n  \"mp4\":\"video/mp4\",\n  \"mp41\":\"video/mp4\",\n  \"mp42\":\"video/mp4\",\n  \"mpg\":\"video/mpeg\",\n  \"mpga\":\"audio/mpeg\",\n  \"ms\":\"application/x-troff-ms\",\n  \"mustache\":\"text/plain\",\n  \"nc\":\"application/x-netcdf\",\n  \"oda\":\"application/oda\",\n  \"ogm\":\"application/ogg\",\n  \"pbm\":\"image/x-portable-bitmap\",\n  \"pdf\":\"application/pdf\",\n  \"pgm\":\"image/x-portable-graymap\",\n  \"pgn\":\"application/x-chess-pgn\",\n  \"pgp\":\"application/pgp\",\n  \"pm\":\"application/x-perl\",\n  \"png\":\"image/png\",\n  \"pnm\":\"image/x-portable-anymap\",\n  \"ppm\":\"image/x-portable-pixmap\",\n  \"ppz\":\"application/vnd.ms-powerpoint\",\n  \"pre\":\"application/x-freelance\",\n  \"prt\":\"application/pro_eng\",\n  \"ps\":\"application/postscript\",\n  \"qt\":\"video/quicktime\",\n  \"ra\":\"audio/x-realaudio\",\n  \"rar\":\"application/x-rar-compressed\",\n  \"ras\":\"image/x-cmu-raster\",\n  \"rgb\":\"image/x-rgb\",\n  \"rm\":\"audio/x-pn-realaudio\",\n  \"rpm\":\"audio/x-pn-realaudio-plugin\",\n  \"rtf\":\"text/rtf\",\n  \"rtx\":\"text/richtext\",\n  \"scm\":\"application/x-lotusscreencam\",\n  \"set\":\"application/set\",\n  \"sgml\":\"text/sgml\",\n  \"sh\":\"application/x-sh\",\n  \"shar\":\"application/x-shar\",\n  \"silo\":\"model/mesh\",\n  \"sit\":\"application/x-stuffit\",\n  \"skt\":\"application/x-koan\",\n  \"smil\":\"application/smil\",\n  \"snd\":\"audio/basic\",\n  \"sol\":\"application/solids\",\n  \"spl\":\"application/x-futuresplash\",\n  \"src\":\"application/x-wais-source\",\n  \"stl\":\"application/SLA\",\n  \"stp\":\"application/STEP\",\n  \"sv4cpio\":\"application/x-sv4cpio\",\n  \"sv4crc\":\"application/x-sv4crc\",\n  \"svg\":\"image/svg+xml\",\n  \"swf\":\"application/x-shockwave-flash\",\n  \"tar\":\"application/x-tar\",\n  \"tcl\":\"application/x-tcl\",\n  \"tex\":\"application/x-tex\",\n  \"texinfo\":\"application/x-texinfo\",\n  \"tgz\":\"application/x-tar-gz\",\n  \"tiff\":\"image/tiff\",\n  \"tr\":\"application/x-troff\",\n  \"tsi\":\"audio/TSP-audio\",\n  \"tsp\":\"application/dsptype\",\n  \"tsv\":\"text/tab-separated-values\",\n  \"unv\":\"application/i-deas\",\n  \"ustar\":\"application/x-ustar\",\n  \"vcd\":\"application/x-cdlink\",\n  \"vda\":\"application/vda\",\n  \"vivo\":\"video/vnd.vivo\",\n  \"vrm\":\"x-world/x-vrml\",\n  \"wav\":\"audio/x-wav\",\n  \"wax\":\"audio/x-ms-wax\",\n  \"webm\":\"video/webm\",\n  \"wma\":\"audio/x-ms-wma\",\n  \"wmv\":\"video/x-ms-wmv\",\n  \"wmx\":\"video/x-ms-wmx\",\n  \"wrl\":\"model/vrml\",\n  \"wvx\":\"video/x-ms-wvx\",\n  \"xbm\":\"image/x-xbitmap\",\n  \"xlw\":\"application/vnd.ms-excel\",\n  \"xml\":\"text/xml\",\n  \"xpm\":\"image/x-xpixmap\",\n  \"xwd\":\"image/x-xwindowdump\",\n  \"xyz\":\"chemical/x-pdb\",\n  \"zip\":\"application/zip\"\n};\n\nexports.lookup = function(ext, defaultType) {\n  defaultType = defaultType || 'application/octet-stream';\n\n  return (ext in exports.types)\n    ? exports.types[ext]\n    : defaultType;\n};","/home/travis/build/npmtest/node-npmtest-elastical/node_modules/elastical/node_modules/request/oauth.js":"var crypto = require('crypto')\n  , qs = require('querystring')\n  ;\n\nfunction sha1 (key, body) {\n  return crypto.createHmac('sha1', key).update(body).digest('base64')\n}\n\nfunction rfc3986 (str) {\n  return encodeURIComponent(str)\n    .replace(/!/g,'%21')\n    .replace(/\\*/g,'%2A')\n    .replace(/\\(/g,'%28')\n    .replace(/\\)/g,'%29')\n    .replace(/'/g,'%27')\n    ;\n}\n\nfunction hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret, body) {\n  // adapted from https://dev.twitter.com/docs/auth/oauth\n  var base = \n    (httpMethod || 'GET') + \"&\" +\n    encodeURIComponent(  base_uri ) + \"&\" +\n    Object.keys(params).sort().map(function (i) {\n      // big WTF here with the escape + encoding but it's what twitter wants\n      return escape(rfc3986(i)) + \"%3D\" + escape(rfc3986(params[i]))\n    }).join(\"%26\")\n  var key = consumer_secret + '&'\n  if (token_secret) key += token_secret\n  return sha1(key, base)\n}\n\nexports.hmacsign = hmacsign\nexports.rfc3986 = rfc3986","/home/travis/build/npmtest/node-npmtest-elastical/node_modules/elastical/node_modules/request/uuid.js":"module.exports = function () {\n  var s = [], itoh = '0123456789ABCDEF';\n \n  // Make array of random hex digits. The UUID only has 32 digits in it, but we\n  // allocate an extra items to make room for the '-'s we'll be inserting.\n  for (var i = 0; i <36; i++) s[i] = Math.floor(Math.random()*0x10);\n \n  // Conform to RFC-4122, section 4.4\n  s[14] = 4;  // Set 4 high bits of time_high field to version\n  s[19] = (s[19] & 0x3) | 0x8;  // Specify 2 high bits of clock sequence\n \n  // Convert to hex chars\n  for (var i = 0; i <36; i++) s[i] = itoh[s[i]];\n \n  // Insert '-'s\n  s[8] = s[13] = s[18] = s[23] = '-';\n \n  return s.join('');\n}\n","/home/travis/build/npmtest/node-npmtest-elastical/node_modules/elastical/node_modules/request/forever.js":"module.exports = ForeverAgent\nForeverAgent.SSL = ForeverAgentSSL\n\nvar util = require('util')\n  , Agent = require('http').Agent\n  , net = require('net')\n  , tls = require('tls')\n  , AgentSSL = require('https').Agent\n\nfunction ForeverAgent(options) {\n  var self = this\n  self.options = options || {}\n  self.requests = {}\n  self.sockets = {}\n  self.freeSockets = {}\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets\n  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets\n  self.on('free', function(socket, host, port) {\n    var name = host + ':' + port\n    if (self.requests[name] && self.requests[name].length) {\n      self.requests[name].shift().onSocket(socket)\n    } else if (self.sockets[name].length < self.minSockets) {\n      if (!self.freeSockets[name]) self.freeSockets[name] = []\n      self.freeSockets[name].push(socket)\n      \n      // if an error happens while we don't use the socket anyway, meh, throw the socket away\n      function onIdleError() {\n        socket.destroy()\n      }\n      socket._onIdleError = onIdleError\n      socket.on('error', onIdleError)\n    } else {\n      // If there are no pending requests just destroy the\n      // socket and it will get removed from the pool. This\n      // gets us out of timeout issues and allows us to\n      // default to Connection:keep-alive.\n      socket.destroy();\n    }\n  })\n\n}\nutil.inherits(ForeverAgent, Agent)\n\nForeverAgent.defaultMinSockets = 5\n\n\nForeverAgent.prototype.createConnection = net.createConnection\nForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest\nForeverAgent.prototype.addRequest = function(req, host, port) {\n  var name = host + ':' + port\n  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {\n    var idleSocket = this.freeSockets[name].pop()\n    idleSocket.removeListener('error', idleSocket._onIdleError)\n    delete idleSocket._onIdleError\n    req._reusedSocket = true\n    req.onSocket(idleSocket)\n  } else {\n    this.addRequestNoreuse(req, host, port)\n  }\n}\n\nForeverAgent.prototype.removeSocket = function(s, name, host, port) {\n  if (this.sockets[name]) {\n    var index = this.sockets[name].indexOf(s);\n    if (index !== -1) {\n      this.sockets[name].splice(index, 1);\n    }\n  } else if (this.sockets[name] && this.sockets[name].length === 0) {\n    // don't leak\n    delete this.sockets[name];\n    delete this.requests[name];\n  }\n  \n  if (this.freeSockets[name]) {\n    var index = this.freeSockets[name].indexOf(s)\n    if (index !== -1) {\n      this.freeSockets[name].splice(index, 1)\n      if (this.freeSockets[name].length === 0) {\n        delete this.freeSockets[name]\n      }\n    }\n  }\n\n  if (this.requests[name] && this.requests[name].length) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(name, host, port).emit('free');\n  }\n}\n\nfunction ForeverAgentSSL (options) {\n  ForeverAgent.call(this, options)\n}\nutil.inherits(ForeverAgentSSL, ForeverAgent)\n\nForeverAgentSSL.prototype.createConnection = createConnectionSSL\nForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest\n\nfunction createConnectionSSL (port, host, options) {\n  options.port = port\n  options.host = host\n  return tls.connect(options)\n}\n","/home/travis/build/npmtest/node-npmtest-elastical/node_modules/elastical/node_modules/request/vendor/cookie/index.js":"/*!\n * Tobi - Cookie\n * Copyright(c) 2010 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar url = require('url');\n\n/**\n * Initialize a new `Cookie` with the given cookie `str` and `req`.\n *\n * @param {String} str\n * @param {IncomingRequest} req\n * @api private\n */\n\nvar Cookie = exports = module.exports = function Cookie(str, req) {\n  this.str = str;\n\n  // Map the key/val pairs\n  str.split(/ *; */).reduce(function(obj, pair){\n   var p = pair.indexOf('=');\n   var key = p > 0 ? pair.substring(0, p).trim() : pair.trim();\n   var lowerCasedKey = key.toLowerCase();\n   var value = p > 0 ? pair.substring(p + 1).trim() : true;\n\n   if (!obj.name) {\n    // First key is the name\n    obj.name = key;\n    obj.value = value;\n   }\n   else if (lowerCasedKey === 'httponly') {\n    obj.httpOnly = value;\n   }\n   else {\n    obj[lowerCasedKey] = value;\n   }\n   return obj;\n  }, this);\n\n  // Expires\n  this.expires = this.expires\n    ? new Date(this.expires)\n    : Infinity;\n\n  // Default or trim path\n  this.path = this.path\n    ? this.path.trim(): req \n    ? url.parse(req.url).pathname: '/';\n};\n\n/**\n * Return the original cookie string.\n *\n * @return {String}\n * @api public\n */\n\nCookie.prototype.toString = function(){\n  return this.str;\n};\n","/home/travis/build/npmtest/node-npmtest-elastical/node_modules/elastical/node_modules/request/vendor/cookie/jar.js":"/*!\n* Tobi - CookieJar\n* Copyright(c) 2010 LearnBoost <dev@learnboost.com>\n* MIT Licensed\n*/\n\n/**\n* Module dependencies.\n*/\n\nvar url = require('url');\n\n/**\n* Initialize a new `CookieJar`.\n*\n* @api private\n*/\n\nvar CookieJar = exports = module.exports = function CookieJar() {\n  this.cookies = [];\n};\n\n/**\n* Add the given `cookie` to the jar.\n*\n* @param {Cookie} cookie\n* @api private\n*/\n\nCookieJar.prototype.add = function(cookie){\n  this.cookies = this.cookies.filter(function(c){\n    // Avoid duplication (same path, same name)\n    return !(c.name == cookie.name && c.path == cookie.path);\n  });\n  this.cookies.push(cookie);\n};\n\n/**\n* Get cookies for the given `req`.\n*\n* @param {IncomingRequest} req\n* @return {Array}\n* @api private\n*/\n\nCookieJar.prototype.get = function(req){\n  var path = url.parse(req.url).pathname\n    , now = new Date\n    , specificity = {};\n  return this.cookies.filter(function(cookie){\n    if (0 == path.indexOf(cookie.path) && now < cookie.expires\n      && cookie.path.length > (specificity[cookie.name] || 0))\n      return specificity[cookie.name] = cookie.path.length;\n  });\n};\n\n/**\n* Return Cookie string for the given `req`.\n*\n* @param {IncomingRequest} req\n* @return {String}\n* @api private\n*/\n\nCookieJar.prototype.cookieString = function(req){\n  var cookies = this.get(req);\n  if (cookies.length) {\n    return cookies.map(function(cookie){\n      return cookie.name + '=' + cookie.value;\n    }).join('; ');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-elastical/node_modules/elastical/node_modules/request/tunnel.js":"'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port) {\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === host && pending.port === port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port) {\n  var self = this;\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push({host: host, port: port, request: req});\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket({host: host, port: port, request: req}, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, host, port);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket();\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false\n  });\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode === 200) {\n      assert.equal(head.length, 0);\n      debug('tunneling connection has established');\n      self.sockets[self.sockets.indexOf(placeholder)] = socket;\n      cb(socket);\n    } else {\n      debug('tunneling socket could not be established, statusCode=%d',\n            res.statusCode);\n      var error = new Error('tunneling socket could not be established, ' +\n                            'sutatusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n    }\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, mergeOptions({}, self.options, {\n      socket: socket\n    }));\n    cb(secureSocket);\n  });\n}\n\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","/home/travis/build/npmtest/node-npmtest-elastical/node_modules/elastical/lib/util.js":"/**\nVarious utility methods.\n\n@module elastical\n@submodule util\n**/\n\n/**\nIterates over all items in _obj_ if _obj_ is an array, or over all enumerable\nproperties if _obj_ is an object, calling the _callback_ for each one.\n\n@method each\n@param {Array|Object} obj Array or object to iterate over.\n@param {callback}\n  @param {mixed} value Value of the current array item or property.\n  @param {Number|String} key Index (if _obj_ is an array) or key (if _obj_ is an\n      object).\n@static\n**/\nfunction each(obj, callback) {\n    if (Array.isArray(obj)) {\n        obj.forEach(callback);\n    } else {\n        Object.keys(obj).forEach(function (key) {\n            callback(obj[key], key);\n        });\n    }\n}\nexports.each = each;\n\n/**\nReturns a new object containing a deep merge of the enumerable properties of all\npassed objects. Properties in later arguments take precedence over properties\nwith the same name in earlier arguments. Object values are deep-cloned. Array and Date\nvalues are _not_ deep-cloned.\n\n@method merge\n@param {object} obj* One or more objects to merge.\n@return {object} New object with merged values from all other objects.\n@static\n**/\nfunction merge() {\n    var args   = Array.prototype.slice.call(arguments),\n        target = {};\n\n    args.unshift(target);\n    mix.apply(this, args);\n\n    return target;\n}\nexports.merge = merge;\n\n/**\nLike `merge()`, but augments the first passed object with a deep merge of the\nenumerable properties of all other passed objects, rather than returning a\nbrand new object.\n\n@method mix\n@param {object} target Object to receive mixed-in properties.\n@param {object} obj* One or more objects to mix into _target_.\n@return {object} Reference to the same _target_ object that was passed in.\n@static\n**/\nfunction mix() {\n    var args   = Array.prototype.slice.call(arguments),\n        target = args.shift(),\n        i, key, keys, len, source, value;\n\n    while ((source = args.shift())) {\n        keys = Object.keys(source);\n\n        for (i = 0, len = keys.length; i < len; ++i) {\n            key   = keys[i];\n            value = source[key];\n\n            if(value == null){\n                // if value is null or undefined keep the value intact.\n                target[key] = value;\n            }else if (typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {\n                typeof target[key] === 'object' || (target[key] = {});\n                mix(target[key], value);\n            } else {\n                target[key] = value;\n            }\n        }\n    }\n\n    return target;\n}\nexports.mix = mix;\n\n/**\nReturns an array containing the values of all enumerable properties of _obj_. If\n_obj_ is already an array, a copy of it will be returned.\n\n@method values\n@param {Array|Object} obj\n@return {Array} values\n@static\n**/\nfunction values(obj) {\n    var i, items, keys, len;\n\n    if (Array.isArray(obj)) {\n        items = obj.concat();\n    } else {\n        keys  = Object.keys(obj);\n        items = [];\n\n        for (i = 0, len = keys.length; i < len; ++i) {\n            items.push(obj[keys[i]]);\n        }\n    }\n\n    return items;\n}\nexports.values = values;\n","/home/travis/build/npmtest/node-npmtest-elastical/node_modules/elastical/lib/index.js":"/**\nProvides methods for creating, deleting, and interacting with ElasticSearch\nindices.\n\n@module elastical\n@submodule index\n@class Index\n@param {Client} client Client instance.\n@param {String} name Index name.\n@constructor\n**/\n\nvar util   = require('./util'),\n    encode = encodeURIComponent;\n\nfunction Index(client, name) {\n    this.client = client;\n    this.name   = name;\n}\n\n/**\nPerforms multiple document create/index/delete operations in a single request.\n\nThe _operations_ parameter should be an array of objects. Each object must\nadhere to one of the following formats.\n\n#### Operation Objects\n\n**Create a Document**\n\n    {\n        create: {\n            index: 'index-name',\n            type : 'type-name',\n            id   : 'document-id',\n            data  : { ... document data ... },\n\n            // Optional properties.\n            parent      : '...',\n            percolate   : '...',\n            routing     : '...',\n            version     : '...',\n            version_type: 'internal' | 'external'\n        }\n    }\n\n**Index a Document**\n\n    {\n        index: {\n            index: 'index-name',\n            type : 'type-name',\n            id   : 'document-id',\n            data  : { ... document data ... },\n\n            // Optional properties.\n            parent      : '...',\n            percolate   : '...',\n            routing     : '...',\n            version     : '...',\n            version_type: 'internal' | 'external'\n        }\n    }\n\n**Delete a Document**\n\n    {\n        delete: {\n            index: 'index-name',\n            type : 'type-name',\n            id   : 'document-id',\n\n            // Optional properties.\n            parent : '...',\n            routing: '...',\n            version: '...'\n        }\n    }\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/bulk.html)\n\n@example\n\n    index.bulk(client, [\n        {create: {index: 'blog', type: 'post', id: '1', data: {\n            title: 'Hello',\n            body : 'Welcome to my stupid blog.'\n        }}},\n\n        {index: {index: 'blog', type: 'post', id: '2', data: {\n            title: 'Breaking news',\n            body : 'Today I ate a sandwich.'\n        }}},\n\n        {index: {index: 'blog', type: 'post', id: '3', percolate: '*', data: {\n            title: 'Percolate this',\n            body : 'Run against all percolators.'\n        }}},\n\n        {delete: {index: 'blog', type: 'post', id: '42'}}\n    ], function (err, res) {\n        // ...\n    });\n\n@method bulk\n@param {Client} client Client instance.\n@param {Object[]} operations Array of operations to perform. See above for a\n    description of the expected object format.\n@param {Object} [options] Options.\n    @param {String} [options.consistency=\"quorum\"] Write consistency to use\n        for these operations. Permitted values are \"one\", \"quorum\", and \"all\".\n        See the ElasticSearch docs for details.\n    @param {Boolean} [options.refresh=false] If `true`, the relevant shard\n        will be refreshed after the delete operation. This may cause heavy\n        server load, so use with caution.\n    @param {String} [options.index=\"indexname\"] If specified the url endpoint\n        for the bulk operations will include this index.  This is useful for\n        scenarios where the root -bulk endpoint is prevented on a shared\n        cluster.\n@param {Function} [callback] Callback function.\n    @param {Error|null} callback.err Error, or `null` on success.\n    @param {Object} callback.res ElasticSearch response data.\n@static\n@see Client.bulk\n**/\nIndex.bulk = function (client, operations, options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n        options  = {};\n    }\n\n    callback || (callback = noop);\n    options || (options = {});\n\n    var body  = [],\n        query = [],\n        url   = '/_bulk';\n\n    if (options.index) {\n        url = '/' + encode(options.index) + '/_bulk';\n        delete options.index;\n    }\n\n    operations.forEach(function (op) {\n        var action = Object.keys(op)[0],\n            input  = op[action],\n            line   = {},\n            name;\n\n        line[action] = {};\n\n        for (name in input) {\n            if (name !== 'data' && input.hasOwnProperty(name)) {\n                // Allow '_index', '_type', etc. in addition to 'index', 'type',\n                // etc.\n                if (name.charAt(0) === '_') {\n                    line[action][name] = input[name];\n                } else {\n                    // ElasticSearch currently only supports 'percolate', not\n                    // '_percolate'.\n                    if (name === 'percolate') {\n                        line[action][name] = input[name];\n                    } else {\n                        line[action]['_' + name] = input[name];\n                    }\n                }\n            }\n        }\n\n        body.push(JSON.stringify(line));\n\n        if (action === 'create' || action === 'index') {\n            body.push(JSON.stringify(input.data || {}));\n        }\n    });\n\n    util.each(options, function (value, name) {\n        if (value === true || value === false) {\n            value = value ? '1' : '0';\n        }\n\n        query.push(encode(name) + '=' + encode(value));\n    });\n\n    if (query.length) {\n        url += '?' + query.join('&');\n    }\n\n    client._request(url, {\n        method: 'PUT',\n        body  : body.join('\\n') + '\\n'\n    }, callback);\n};\n\n/**\nCreates a new index.\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-create-index.html)\n\n@method create\n@param {Client} client Client instance.\n@param {String} name Name of the new index.\n@param {Object} [options] Index options (see ElasticSearch docs for details).\n@param {Function} [callback] Callback function.\n    @param {Error|null} callback.err Error, or `null` on success.\n    @param {Index} callback.index Index instance for the newly created index.\n    @param {Object} callback.data ElasticSearch response data.\n@static\n@see Client.createIndex\n**/\nIndex.create = function (client, name, options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n        options  = {};\n    }\n\n    client._request('/' + encode(name), {\n        method: 'PUT',\n        json  : options\n    }, callback && function (err, data) {\n        if (err) { return callback(err, data), undefined; }\n        callback(null, client.getIndex(name), data);\n    });\n};\n\n/**\nDeletes the specified index or indices. If no indices are specified, **all**\nindices on the server will be deleted.\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-delete-index.html)\n\n@method delete\n@param {Client} client Client instance.\n@param {String|String[]} [names] Name of the index to delete, or an array of\n    names to delete multiple indices. If omitted, **all** indices will be\n    deleted.\n@param {Function} [callback] Callback function.\n  @param {Error|null} callback.err Error, or `null` on success.\n  @param {Object} callback.data ElasticSearch response data.\n@static\n@see Client.deleteIndex\n**/\nIndex.delete = function (client, names, callback) {\n    if (typeof names === 'function') {\n        callback = names;\n        names    = undefined;\n    }\n\n    if (Array.isArray(names)) {\n        names = names.join(',');\n    }\n\n    client._request('/' + encode(names || ''), {method: 'DELETE'}, callback);\n};\n\n/**\nChecks whether the specified index or indices exist.\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-indices-exists.html)\n\n@method exists\n@param {Client} client Client instance.\n@param {String|String[]} names Index name or array of names to check.\n@param {Function} callback Callback function.\n  @param {Error|null} callback.err Error, or `null` on success.\n  @param {Boolean} callback.exists `true` if all specified indices exist,\n      `false` otherwise.\n@static\n@see Client.indexExists\n**/\nIndex.exists = function (client, names, callback) {\n    if (Array.isArray(names)) {\n        names = names.join(',');\n    }\n\n    client._request('/' + encode(names), {method: 'HEAD'}, function (err) {\n        callback(null, !err);\n    });\n};\n\n/**\nRetrieve the mappings for one or more indices.\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-get-mapping.html)\n\n@method count\n@param {Client} client Client instance.\n@param {String|String[]} names Index name or array of names.\n@param {String} [type] Document type. If omitted, count for all types are returned.\n@param {String} query query. If omitted, count for a match_all is returned.\n@param {Function} callback Callback function.\n  @param {Error|null} callback.err Error, or `null` on success.\n  @param {Object} callback.res ElasticSearch response data.\n@static\n@see Client.count\n**/\nIndex.count = function (client, names, type, query, callback) {\n    var url;\n    if (typeof query === 'function') {\n        callback = query;\n        query     = null;\n    }\n    if (typeof type === 'function') {\n        callback = type;\n        query     = null;\n        type     = null;\n    }\n\n    if (Array.isArray(names)) {\n        names = names.join(',');\n    }\n\n    names = names.trim();\n    url   = '/' + encode(names);\n\n    if (type) {\n        url += '/' + encode(type);\n    }\n\n    url += '/_count';\n    if (query) {\n        url += '?q=' + encode(query);\n    } else {\n      // count in elastic Search require a query and returns an error if it does not find it:\n      // {\"error\":\"No query to execute, not in body, and not bounded to 'q' parameter\"}%\n      // perhaps there is better than that to do?\n      url += '?q=*';\n    }\n\n    client._request(url, callback);\n}\n\n/**\nRetrieve the mappings for one or more indices.\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-get-mapping.html)\n\n@method getMapping\n@param {Client} client Client instance.\n@param {String|String[]} names Index name or array of names.\n@param {String} [type] Document type. If omitted, mappings for all types are returned.\n@param {Function} callback Callback function.\n  @param {Error|null} callback.err Error, or `null` on success.\n  @param {Object} callback.res ElasticSearch response data.\n@static\n@see Client.getMapping\n**/\nIndex.getMapping = function (client, names, type, callback) {\n    var url;\n\n    if (typeof type === 'function') {\n        callback = type;\n        type     = null;\n    }\n\n    if (Array.isArray(names)) {\n        names = names.join(',');\n    }\n\n    names = names.trim();\n    url   = '/' + encode(names);\n\n    if (type) {\n        url += '/' + encode(type);\n    }\n\n    url += '/_mapping';\n\n    client._request(url, callback);\n}\n\n/**\nRetrieve the settings for one or more indices.\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-get-settings.html)\n\n@method getSettings\n@param {Client} client Client instance.\n@param {String|String[]} names Index name or array of names.\n@param {Function} callback Callback function.\n  @param {Error|null} callback.err Error, or `null` on success.\n  @param {Object} callback.res ElasticSearch response data.\n@static\n@see Client.getSettings\n**/\nIndex.getSettings = function (client, names, callback) {\n    var url;\n\n    if (Array.isArray(names)) {\n        names = names.join(',');\n    }\n\n    names = names.trim();\n    url   = '/' + encode(names);\n\n    url += '/_settings';\n\n    client._request(url, callback);\n}\n\n/**\nUpdate the settings for one or more indices.\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-update-settings/)\n\n@method updateSettings\n@param {Client} client Client instance.\n@param {String|String[]} index Index name or array of names. If not specified,\n    it will be applied to all indices\n@param {Object} settings Settings. See ElasticSearch docs for details.\n@param {Function} callback Callback function.\n  @param {Error|null} callback.err Error, or `null` on success.\n  @param {Object} callback.res ElasticSearch response data.\n@static\n@see Client.updateSettings\n**/\nIndex.updateSettings = function (client, index, settings, callback) {\n    var params, url = '';\n\n    if (typeof index === 'object' && !Array.isArray(index)) {\n        callback = settings;\n        settings = index;\n        index = null;\n    }\n\n    callback || (callback = noop);\n\n    if (index) {\n        if (Array.isArray(index)) {\n            index = index.join(',');\n        }\n\n        index = index.trim();\n        url   = '/' + encode(index);\n    }\n\n    url += '/_settings';\n\n    client._request(url, {\n        method: 'PUT',\n        json: settings\n    }, callback);\n}\n\n/**\n Apply aliases actions.\n\n [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-aliases.html)\n\n @method addAlias\n @param {Client} client Client instance.\n @param {Object[]} actions Aliases actions.\n @param {Function} callback Callback function.\n @param {Error|null} callback.err Error, or `null` on success.\n @param {Object} callback.res ElasticSearch response data.\n @static\n @see Client.applyAliasesActions\n **/\nIndex.applyAliasesActions = function (client, actions, callback) {\n    client._request('/_aliases', {\n        method: 'POST',\n        json: {actions:actions}\n    }, callback);\n}\n\n/**\n Get aliases.\n\n [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-aliases.html)\n\n @method getAliases\n @param {Client} client Client instance.\n @param {String|String[]|null} names Index name or array of names.\n @param {Function} callback Callback function.\n @param {Error|null} callback.err Error, or `null` on success.\n @param {Object} callback.res ElasticSearch response data.\n @static\n @see Client.getAliases\n **/\nIndex.getAliases = function (client, names, callback) {\n    var url = '';\n\n    if(names){\n        if (Array.isArray(names)) {\n            names = names.join(',');\n        }\n\n        names = names.trim();\n        url = '/' + encode(names);\n    }\n\n    url += '/_aliases';\n\n    client._request(url, callback);\n}\n\n/**\nRegisters a mapping definition for the specified type within the specified\nindex or indices.\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-put-mapping.html)\n\n@method putMapping\n@param {Client} client Client instance.\n@param {String|String[]} [names] Index name or array of names to define the\n    mapping within. If not specified, it will be defined in all indices.\n@param {String} type Document type.\n@param {Object} [mapping] Mapping definition. See the [ElasticSearch\n    docs](http://www.elasticsearch.org/guide/reference/mapping/) for\n    an overview.\n@param {Function} [callback] Callback function.\n  @param {Error|null} callback.err Error, or `null` on success.\n  @param {Object} callback.res ElasticSearch response data.\n@static\n@see Client.putMapping\n**/\nIndex.putMapping = function (client, names, type, mapping, callback) {\n    if (typeof type === 'object') {\n        callback = mapping;\n        mapping  = type;\n        type     = names;\n        names    = undefined;\n    }\n\n    if (Array.isArray(names)) {\n        names = names.join(',');\n    }\n\n    names || (names = '_all');\n\n    client._request('/' + encode(names) + '/' + encode(type) + '/_mapping', {\n        method: 'PUT',\n        json: mapping\n    }, callback);\n}\n\n/**\nRefreshes the specified index or indices.\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-refresh.html)\n\n@method refresh\n@param {Client} client Client instance.\n@param {String|String[]} [names] Index name or array of names to refresh. If not\n    specified, all indices will be refreshed.\n@param {Function} [callback] Callback function.\n  @param {Error|null} callback.err Error, or `null` on success.\n  @param {Object} callback.res ElasticSearch response data.\n@static\n@see Client.refresh\n**/\nIndex.refresh = function (client, names, callback) {\n    if (typeof names === 'function') {\n        callback = names;\n        names    = undefined;\n    }\n\n    if (Array.isArray(names)) {\n        names = names.join(',');\n    }\n\n    names || (names = '_all');\n\n    client._request('/' + encode(names) + '/_refresh', {method: 'POST'},\n        callback);\n};\n\n/**\n Analyze\n\n [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-analyze.html)\n\n @method analyze\n @param {Client} client Client instance.\n @param {String} text Text to analyze\n @param {Object} [options] Options. See ElasticSearch docs for details.\n     @param {String} [options.index=\"indexname\"] Index name whose analyzer must be used. If not\n         specified, use built-in analyzers.\n     @param {String} [options.analyzer=\"standard\"] Analyzer to use for analysis\n     @param {String} [options.tokenizer=\"keyword\"] Tokenizer to use for analysis when\n         using a custom transient analyzer\n     @param {String} [options.field=\"obj1.field1\"] Use the analyzer configured in\n         the mapping for this field\n @param {Function} [callback] Callback function.\n    @param {Error|null} callback.err Error, or `null` on success.\n    @param {Object} callback.res ElasticSearch response data.\n @static\n @see Client.analyze\n**/\nIndex.analyze = function (client, text, options, callback) {\n    var params, url = '/_analyze';\n    if (typeof options === 'function') {\n        callback = options;\n        options  = {};\n    }\n\n    callback || (callback = noop);\n    params = util.merge(options);\n\n    if (params.index) {\n        url = '/' + encode(params.index) + '/_analyze';\n        delete params.index;\n    }\n\n    var query = [ 'text=' + encode(text) ];\n    util.each(params, function (value, name) {\n        query.push(encode(name) + '=' + encode(value));\n    });\n\n    if (query.length) {\n        url += '?' + query.join('&');\n    }\n\n    client._request(url, { method: 'GET' }, callback);\n};\n\n/**\nRegisters a river with the cluster.\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/river/)\n\n@method putRiver\n@param {Client} client Client instance.\n@param {String} name A name for this river.\n@param {Object} config The river configuration.\n@param {Function} [callback] Callback function.\n  @param {Error|null} callback.err Error, or `null` on success.\n  @param {Object} callback.res ElasticSearch response data.\n@static\n**/\nIndex.putRiver = function( client, name, config, callback ){\n    client._request('/_river/' + name + '/_meta', {\n        method: 'PUT',\n        json: config\n    }, callback);\n};\n\n/**\nGets river config from the cluster.\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/river/)\n\n@method getRiver\n@param {Client} client Client instance.\n@param {String} name A name for this river.\n@param {Function} [callback] Callback function.\n  @param {Error|null} callback.err Error, or `null` on success.\n  @param {Object} callback.res ElasticSearch response data.\n@static\n**/\nIndex.getRiver = function( client, name, callback ){\n    client._request('/_river/' + name + '/_meta', { method: 'GET' }, callback);\n};\n\n/**\nDeletes a river config from the cluster.\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/river/)\n\n@method deleteRiver\n@param {Client} client Client instance.\n@param {String} name A name for this river.\n@param {Function} [callback] Callback function.\n  @param {Error|null} callback.err Error, or `null` on success.\n  @param {Object} callback.res ElasticSearch response data.\n@static\n**/\nIndex.deleteRiver = function( client, name, callback ){\n    client._request('/_river/' + name, { method: 'DELETE' }, callback);\n};\n\n/**\nMulti GET API allows to get multiple documents\n\n[ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/multi-get.html)\n\n@method multiGet\n@param {Client} client Client instance.\n@param {String|null} index optional Index name.\n@param {String|null} type optional document type.\n@param {Object} data either docs or ids\n  @param {Object[]} [data.docs] docs to query (can include _index, _type, _id, fields)\n  @param {String[]} [data.ids] ids to query\n@param {Function} callback Callback function.\n  @param {Error|null} callback.err Error, or `null` on success.\n  @param {Object} callback.res ElasticSearch response data.\n@see Client.multiGet\n **/\nIndex.multiGet= function (client, index, type, data, callback) {\n    var url = '';\n    if(index)\n        url +='/'+encode(index)   ;\n    if(type)\n        url +=  '/'+encode(type) ;\n    url += '/_mget';\n    client._request(url, {\n        method: 'POST',\n        json  : data\n    }, callback);\n};\n\nIndex.prototype = {\n    // http://www.elasticsearch.org/guide/reference/api/count.html\n    count: function (query, callback) {\n\n    },\n\n    /**\n    Deletes a document from this index.\n\n    @method delete\n    @param {String} type Type name.\n    @param {String} id Document id to delete.\n    @param {Object} [options] Delete options.\n      @param {String} [options.consistency=\"quorum\"] Write consistency to use\n          for this indexing operation. Permitted values are \"one\", \"quorum\" and\n          \"all\". See the ElasticSearch docs for details.\n      @param {Boolean} [options.ignoreMissing=false] If `true`, an error will\n          not be returned if the index, type, or document do not exist.\n      @param {String} [options.parent] Parent document id.\n      @param {Boolean} [options.refresh=false] If `true`, the relevant shard\n          will be refreshed after the delete operation. This may cause heavy\n          server load, so use with caution.\n      @param {String} [options.replication=\"sync\"] Replication mode for this\n          indexing operation. Maybe be set to \"sync\" or \"async\".\n      @param {String} [options.routing] Value that determines what shard this\n          operation will be routed to. Note that an incorrectly routed operation\n          will fail, so it's best to leave this alone unless you know your\n          business.\n      @param {Number} [options.version] Document version to delete. If\n          the specified document's version differs from this, an error will be\n          returned and the document will not be deleted.\n      @param {object} [options.query] To perform removal using a query. Warning:\n          id and all other options except ignoreMissing will be ignored.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response.\n    @see Client.delete\n    **/\n    delete: function (type, id, options, callback) {\n        var query = [],\n            ignoreMissing, params, url;\n\n        if (typeof options === 'function') {\n            callback = options;\n            options  = {};\n        }\n\n        callback || (callback = noop);\n        params = util.merge(options);\n\n        if (typeof params.ignoreMissing !== 'undefined') {\n            ignoreMissing = params.ignoreMissing;\n            delete params.ignoreMissing;\n        }\n\n        if(params.query) {\n            url = '/' + encode(this.name);\n            if (type) {\n                url += '/' + encode(Array.isArray(type) ? type.join(',') : type);\n            }\n            url += '/_query';\n            \n            this.client._request(url, {method: 'DELETE', json: params.query}, function (err, res) {\n                if (err) {\n                    if (ignoreMissing && res && res.found === false) {\n                        return callback(null, res), undefined;\n                    } else {\n                        return callback(err, res), undefined;\n                    }\n                }\n                callback(null, res);\n            });\n        } else {\n            util.each(params, function (value, name) {\n                if (value === true || value === false) {\n                    value = value ? '1' : '0';\n                }\n  \n                query.push(encode(name) + '=' + encode(value));\n            });\n  \n            url = '/' + encode(this.name) + '/' + encode(type) + '/' + encode(id);\n  \n            if (query.length) {\n                url += '?' + query.join('&');\n            }\n  \n            this.client._request(url, {method: 'DELETE'}, function (err, res) {\n                if (err) {\n                    if (ignoreMissing && res && res.found === false) {\n                        return callback(null, res), undefined;\n                    } else {\n                        return callback(err, res), undefined;\n                    }\n                }\n  \n                callback(null, res);\n            });\n        }\n    },\n\n    /**\n    Deletes this index.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-delete-index.html)\n\n    @method deleteIndex\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.data ElasticSearch response data.\n    **/\n    deleteIndex: function (callback) {\n        Index.delete(this.client, this.name, callback);\n    },\n\n    // http://www.elasticsearch.org/guide/reference/api/admin-indices-delete-mapping.html\n    deleteMapping: function (type) {\n\n    },\n\n    /**\n    Checks whether this index exists on the server.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-indices-exists.html)\n\n    @method exists\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Boolean} callback.exists `true` if the index exists, `false`\n        otherwise.\n    **/\n    exists: function (callback) {\n        Index.exists(this.client, this.name, callback);\n    },\n\n    /**\n    Gets a document from this index based on its id.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/get.html)\n\n    @method get\n    @param {String} id Document id.\n    @param {Object} [options] Options.\n      @param {String|String[]} [options.fields] Document field name or array of\n          field names to retrieve. By default, all fields are retrieved.\n      @param {Boolean} [options.ignoreMissing=false] If `true`, an error will\n          not be returned if the index, type, or document do not exist. Instead,\n          a `null` document will be returned.\n      @param {String} [options.preference] Controls which shard replicas the\n          request should be executed on. By default, the operation will be\n          randomized between the shard replicas. See the ElasticSearch docs for\n          possible values.\n      @param {Boolean} [options.realtime=true] Whether or not to use realtime\n          GET. See the ElasticSearch docs for details.\n      @param {Boolean} [options.refresh=false] If `true`, the relevant shard\n          will be refreshed before the get operation to ensure that it's\n          searchable. This may cause heavy server load, so use with caution.\n      @param {String} [options.routing] Value that determines what shard this\n          document will be routed to. If not specified, a hash of the document's\n          id will be used. Note that an incorrectly routed get operation will\n          fail, so it's best to leave this alone unless you know your business.\n      @param {String} [options.type=\"_all\"] If specified, the get operation will\n          be limited to documents of this type.\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object|null} callback.doc Retrieved document or document fields,\n          or `null` if the document was not found and `options.ignoreMissing` is\n          `true`.\n      @param {Object} callback.res Full ElasticSearch response data.\n    @see Client.get\n    **/\n    get: function (id, options, callback) {\n        var query = [],\n            type  = '_all',\n            ignoreMissing, params, url;\n\n        if (typeof options === 'function') {\n            callback = options;\n            options  = {};\n        }\n\n        params = util.merge(options);\n\n        if (params.fields) {\n            params.fields = Array.isArray(params.fields) ?\n                params.fields.join(',') : params.fields;\n        }\n\n        if (typeof params.ignoreMissing !== 'undefined') {\n            ignoreMissing = params.ignoreMissing;\n            delete params.ignoreMissing;\n        }\n\n        if (params.type) {\n            type = params.type;\n            delete params.type;\n        }\n\n        util.each(params, function (value, name) {\n            if (value === true || value === false) {\n                value = value ? '1' : '0';\n            }\n\n            query.push(encode(name) + '=' + encode(value));\n        });\n\n        url = '/' + encode(this.name) + '/' + encode(type) + '/' + encode(id);\n\n        if (query.length) {\n            url += '?' + query.join('&');\n        }\n\n        this.client._request(url, {method: 'GET'}, function (err, res) {\n            if (err) {\n                if (ignoreMissing && res && (res.exists === false\n                        || res.error.indexOf('IndexMissing') !== -1)) {\n                    return callback(null, null, res), undefined;\n                } else {\n                    return callback(err, null, res), undefined;\n                }\n            }\n\n            callback(null, res.fields || res._source, res);\n        });\n    },\n\n    /**\n    Gets the mapping definition for this index.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-get-mapping.html)\n\n    @method getMapping\n    @param {String} [type] Document type. If omitted, mappings for all types are returned.\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @see Client.getMapping\n    **/\n    getMapping: function (type, callback) {\n        Index.getMapping.apply(null, [this.client, this.name].concat(\n            Array.prototype.slice.call(arguments)));\n    },\n\n    /**\n    Adds a document to this index.\n\n    If a document already exists in this index with the specified _type_ and\n    _id_, it will be updated. Otherwise, a new document will be created.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/index_.html)\n\n    @example\n\n        var blog = client.getIndex('blog');\n\n        blog.index('post', {\n            title  : \"Welcome to my stupid blog\",\n            content: \"This is the first and last time I'll post anything.\",\n            tags   : ['welcome', 'first post', 'last post'],\n            created: Date.now()\n        }, function (err, res) {\n            if (err) { throw err; }\n            console.log('Indexed a blog post');\n        });\n\n    @method index\n    @param {String} type Document type.\n    @param {Object} doc Document data to index.\n    @param {Object} [options] Options.\n      @param {String} [options.consistency=\"quorum\"] Write consistency to use\n          for this indexing operation. Permitted values are \"one\", \"quorum\" and\n          \"all\". See the ElasticSearch docs for details.\n      @param {Boolean} [options.create=false] Only create the document if it\n          doesn't already exist.\n      @param {String} [options.id] Document id. One will be automatically\n          generated if not specified.\n      @param {String} [options.parent] Parent document id.\n      @param {String} [options.percolate] Percolation query to check against\n          this document. See the ElasticSearch docs for details.\n      @param {Boolean} [options.refresh=false] If `true`, the document will be\n          made searchable immediately after it is indexed.\n      @param {String} [options.replication=\"sync\"] Replication mode for this\n          indexing operation. Maybe be set to \"sync\" or \"async\".\n      @param {String} [options.routing] Value that determines what shard this\n          document will be routed to. If not specified, a hash of the document's\n          id will be used.\n      @param {String} [options.timeout=\"1m\"] How long to wait for the primary\n          shard to become available to index this document before aborting. See\n          the ElasticSearch docs for details. This should be a value like \"5m\"\n          (5 minutes) or \"15s\" (15 seconds).\n      @param {Number} [options.version] Document version to create/update. If\n          this is set and `options.version_type` is not set,\n          `options.version_type` will automatically be set to \"external\".\n      @param {String} [options.version_type=\"internal\"] Version type (either\n          \"internal\" or \"external\"). See the ElasticSearch docs for details.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @see Client.index\n    **/\n    index: function (type, doc, options, callback) {\n        var query = [],\n            id, params, url;\n\n        if (typeof options === 'function') {\n            callback = options;\n            options  = {};\n        }\n\n        params = util.merge(options || {});\n\n        if (params.create) {\n            params.op_type = 'create';\n            delete params.create;\n        }\n\n        if (params.id) {\n            id = params.id;\n            delete params.id;\n        }\n\n        if (params.version && !params.version_type) {\n            params.version_type = 'external';\n        }\n\n        util.each(params, function (value, name) {\n            if (value === true || value === false) {\n                value = value ? '1' : '0';\n            }\n\n            query.push(encode(name) + '=' + encode(value));\n        });\n\n        url = '/' + encode(this.name) + '/' + encode(type);\n\n        if (id) {\n            url += '/' + encode(id);\n        }\n\n        if (query.length) {\n            url += '?' + query.join('&');\n        }\n\n        this.client._request(url, {\n            method: id ? 'PUT' : 'POST',\n            json  : doc\n        }, callback);\n    },\n\n    // http://www.elasticsearch.org/guide/reference/api/admin-indices-optimize.html\n    optimize: function (options) {\n\n    },\n\n    /**\n    Registers a mapping definition for the specified type within this index.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-put-mapping.html)\n\n    @method putMapping\n    @param {String} type Document type.\n    @param {Object} [mapping] Mapping definition. See the [ElasticSearch\n        docs](http://www.elasticsearch.org/guide/reference/mapping/) for\n        an overview.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @see Client.putMapping\n    **/\n    putMapping: function (type, mapping, callback) {\n        Index.putMapping(this.client, this.name, type, mapping, callback);\n    },\n\n    /**\n    Analyze using analyzer from this index\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-analyze.html)\n\n    @method analyze\n    @param {String} text Text to analyze\n    @param {Object} [options] Options. See ElasticSearch docs for details.\n      @param {String} [options.analyzer=\"standard\"] Analyzer to use for analysis\n      @param {String} [options.tokenizer=\"keyword\"] Tokenizer to use for analysis when\n        using a custom transient analyzer\n      @param {String} [options.field=\"obj1.field1\"] Use the analyzer configured in\n        the mapping for this field\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @see Client.analyze\n    **/\n    analyze: function (text, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options  = {};\n        }\n        options.index = this.name;\n        Index.analyze(this.client, options, callback);\n    },\n\n    /**\n    Registers a river with the cluster.\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/river/)\n\n    @method putRiver\n    @param {String} name A name for this river.\n    @param {Object} config The river configuration.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @static\n    **/\n    putRiver: function( name, config, callback ){\n        Index.putRiver( this.client, name, config, callback );\n    },\n\n    /**\n    Gets river config from the cluster.\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/river/)\n\n    @method getRiver\n    @param {Client} client Client instance.\n    @param {String} name A name for this river.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @static\n    **/\n    getRiver: function( name, callback ){\n        Index.getRiver( this.client, name, callback );\n    },\n\n    /**\n    Deletes a river config from the cluster.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/river/)\n\n    @method deleteRiver\n    @param {Client} client Client instance.\n    @param {String} name A name for this river.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @static\n    **/\n    deleteRiver: function( name, callback ){\n        Index.deleteRiver( this.client, name, callback );\n    },\n\n    /**\n    Refreshes this index.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-refresh.html)\n\n    @method refresh\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @see Client.refresh\n    **/\n    refresh: function (callback) {\n        Index.refresh(this.client, this.name, callback);\n    },\n\n    /**\n    Searches for documents in this index matching the given query. See\n    `Client.search()` for the complete list of supported options.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/search/)\n\n    @method search\n    @param {Object} [options] Search options. Technically this argument is\n        optional, but you'll almost always want to provide at least a query.\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.results Search results.\n      @param {Object} callback.res Full ElasticSearch response data.\n    @see Client.search\n    **/\n    search: function (options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options  = {};\n        }\n\n        this.client.search(util.merge(options, {index: this.name}), callback);\n    },\n\n    /**\n    Provide statistics on different operations happening on an index.\n    See `Client.stats()` for the complete list of supported options.\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/admin-indices-stats.html)\n\n    @method stats\n    @param {Object} [options] Stats options. This argument is optional.\n    @param {Function} [callback] Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res ElasticSearch response data.\n    @see Client.stats\n    **/\n    stats: function (options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      this.client.stats(util.merge(options, {index: this.name}), callback);\n    },\n\n    // TODO: close, open, get settings, get mapping, flush, snapshot,\n    // update settings, templates, status, segments, clear cache\n    /**\n    Registers a percolator for the given index or modifies the existing percolator\n    if one with the name already exists\n\n    [ElasticSearch docs](http://www.elasticsearch.org/guide/reference/api/pecolator/)\n\n    @example\n        var put =   {\n                        \"query\" : {\n                            \"text\" : {\n                                \"hashtags\" : {\n                                    \"query\" : 'blah blah blah ',\n                                    \"operator\" : \"or\"\n                                }\n                            }\n                        }\n                    };\n        client.percolator('tweets', 'mypercolator', query, function (err, res) {\n            if (err) { throw err; }\n            console.log(results);\n        });\n    @method setPercolator\n    @param {String} percolator The identifier string of the percolator.\n            This identifier is returned when a document matches\n            the query in the percolator, either through percolate operation or\n            through index opertation.\n    @param {Object|String} query Search query. Afull query object.\n        See the [ElasticSearch Query DSL docs](http://www.elasticsearch.org/guide/reference/query-dsl/)\n        for details.\n    @param {Function} callback Callback function.\n      @param {Error|null} callback.err Error, or `null` on success.\n      @param {Object} callback.res Full ElasticSearch response data.\n    */\n    setPercolator: function(percolator, query, callback){\n        var url = '/_percolator/';\n        url += this.name;\n        url += '/'+encode(percolator);\n        this.client._request(url, {\n            method: 'POST',\n            json  : query\n        }, callback);\n    },\n    /**\n     * Retrieve the percolator doc\n     *\n     * @example\n     *\n     *  client.getPercolator('tweets', 'mypercolator', function (err, results) {\n     *      if (err) { throw err; }\n     *      console.log(results);\n     *  });\n     *\n     *  @param {String} percolator The name of the percolator\n     *  @param {Function} callback Callback function.\n     *      @param {Error|null} callback.err Error, or `null` on success.\n     *      @param {Object} callback.doc  Percolator document.\n     *      @param {Object} callback.res Full ElasticSearch response data.\n     */\n    getPercolator: function(percolator, callback){\n        var url = '/_percolator/'+this.name+'/'+encode(percolator);\n        this.client._request(url, {\n            method: 'GET'\n        }, function (err, res) {\n            if (err) { return callback(err, null, res), undefined; }\n            return callback(null, res._source, res);\n        });\n    },\n\n    /**\n     * Test if a given doc matches a percolator for\n     * the given index and document type\n     * @example\n     *      client.perolate('tweets', 'tweet', {\n     *          doc: {\n     *\n     *              title  : \"Welcome to my stupid blog\",\n     *              content: \"This is the first and last time I'll post anything.\",\n     *              tags   : ['welcome', 'first post', 'last post'],\n     *              created: Date.now()\n     *          }\n     *      }, function(err, res){\n     *          if(err){ throw err; }\n     *          console.log(res);\n     *      });\n     *  _NOTE_: You must wrap your document in 'doc' param\n     *  @param {String} type The type name of the document\n     *  @param {Object} doc The document object which the registered percolators\n     *      are matched against\n     *  @param {Function} callback Callback function.\n     *      @param {Error|null} callback.err Error, or `null` on success.\n     *      @param {Object} callback.res Full ElasticSearch response data.\n     */\n    percolate: function(type, doc, callback){\n        // this check is required because elasticsearch does not return an error\n        // but times out if the'doc' element is not present in the body of the\n        // request\n        if(doc['doc'] === undefined){\n            doc = {'doc': doc};\n        }\n        var url = '/'+ this.name+'/'+type+'/_percolate';\n        this.client._request(url, {\n            method: 'GET',\n            json  : doc\n        }, callback);\n    },\n\n    /**\n     * Delete a registered percolator for the given index or indicies\n     * @example\n     *      client.deletePercolator('tweets', 'mypercolator', function(err, res){\n     *          if(err){ throw err;}\n     *          console.log(res);\n     *      });\n     * @param {String|String[]} index Index name or array of index names\n     * @param {String} percolator Name of the percolator to delete\n     * @param {Function} callback Callback function.\n     *      @param {Error|null} callback.err Error, or `null` on success.\n     *      @param {Object} callback.res Full ElasticSearch response data.\n     */\n    deletePercolator: function(percolator, callback){\n        var url = '/_percolator/'+ this.name +'/'+encode(percolator);\n        this.client._request(url, {\n            method: 'DELETE'\n        }, callback);\n    }\n};\n\n/**\nAlias for index().\n\n@method set\n@see index\n**/\nIndex.prototype.set = Index.prototype.index;\n\nmodule.exports = Index;\n\n// -- Private Functions --------------------------------------------------------\nfunction noop() {}\n"}